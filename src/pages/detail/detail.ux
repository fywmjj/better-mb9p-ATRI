<template>
  <!-- Root container -->
  <div class="page-container" @swipe="handleSwipeBack">

    <!-- Dialogue Layer -->
    <div class="dialogue-layer" @click="nextDialogue">
      <!-- èƒŒæ™¯å›¾çš„åŠ è½½è·¯å¾„ï¼Œä¹‹å‰æ˜¯ç›´æ¥åœ¨commonä¸‹æ‰¾ï¼Œç°åœ¨ç»Ÿä¸€æŒªåˆ°imageså­ç›®å½•äº†ï¼Œç®¡ç†èµ·æ¥æ›´è§„èŒƒã€‚ -->
      <image class="dialogue-background" src="/common/images/{{ currentBackground }}"></image>
      <!-- åœºæ™¯å›¾ç‰‡ä¹Ÿæ˜¯ä¸€æ ·ï¼Œè·¯å¾„è°ƒæ•´åˆ°imagesç›®å½•ã€‚ -->
      <image class="scene-image" src="/common/images/{{ gameData.scenes[currentScene].Img }}" style="top:{{gameData.scenes[currentScene].ImgTop}}px; left:{{gameData.scenes[currentScene].ImgLeft}}px;" if="{{ showSceneImage }}"></image>
      <div class="dialogue-ui" if="{{ showDialogueUI }}">
        <!-- å¯¹è¯æ¡†èƒŒæ™¯å›¾ï¼Œè·¯å¾„ä¹Ÿæ›´æ–°äº†ã€‚ -->
        <image class="dialogue-text-bg" src="/common/images/text_bg.png"></image>
        <!-- è§’è‰²åæ˜¾ç¤ºï¼Œè¿™é‡Œä¹‹å‰æœ‰ç‚¹å°é—®é¢˜ï¼Œä½ç½®å¯èƒ½ä¸å¤ªå¯¹åŠ²ï¼Œç°åœ¨åº”è¯¥èƒ½æ­£å¸¸æ˜¾ç¤ºåœ¨å¯¹è¯æ¡†ä¸Šæ–¹äº†ã€‚ -->
        <text class="dialogue-character">{{ characterName }}</text>
        <scroll scroll-y="true" bounces="true" class="dialogue-scroll" id="dialogueScroll">
          <text class="dialogue-text" style="font-size: {{ settings.textSize }}px;">{{ displayedText }}</text>
        </scroll>
      </div>
    </div>

    <!-- Choices Overlay -->
    <!-- Use overlay for positioning context -->
    <div class="overlay choices-overlay" if="{{ showChoicesUI }}">
        <!-- åˆ†æ”¯é€‰æ‹©æŒ‰é’®åˆ—è¡¨ã€‚ä¹‹å‰è¿™é‡Œçš„æ³¨é‡Šå†™åœ¨äº†<text>æ ‡ç­¾é‡Œé¢ï¼Œå¯¼è‡´ç¼–è¯‘å‡ºé”™ï¼ŒæŒ‰é’®æ— æ³•æ­£å¸¸æ˜¾ç¤ºå’Œç‚¹å‡»ã€‚ç°åœ¨æŠŠæ³¨é‡ŠæŒªå‡ºæ¥äº†ï¼Œåº”è¯¥å°±æ²¡é—®é¢˜äº†ã€‚ğŸ˜… -->
        <!-- Position buttons absolutely within the overlay -->
        <text
            class="choice-button"
            for="{{ (index, choice) in gameData.scenes[currentScene].choices }}"
            style="top: {{ 100 + index * 85 }}px; left: 43px;"
            @click="selectChoice(index)">
            {{ choice.text }}
        </text>
    </div>

    <!-- Menu Overlay -->
    <div class="overlay menu-overlay" if="{{ isMenuVisible }}">
      <!-- Standard Menu Buttons -->
      <text class="menu-button" @click="toRecoveryPage(1)">ä¿å­˜</text> <!-- 1 = Save -->
      <text class="menu-button" @click="toRecoveryPage(2)">åŠ è½½</text> <!-- 2 = Load -->
      <!-- Quick Save/Load Buttons -->
      <text class="menu-button quick-save-button" @click="quickSave()">å¿«é€Ÿå­˜æ¡£</text>
      <text class="menu-button" @click="quickLoad()">å¿«é€Ÿè¯»æ¡£</text>
      <!-- Other Buttons -->
      <text class="menu-button" @click="skipScene()">è·³è¿‡åœºæ™¯</text>
      <text class="menu-button" @click="skipCurrentChapter()">è·³è¿‡ç« èŠ‚</text>
      <text class="menu-button" @click="closeMenu()">è¿”å›</text>
      <text class="menu-button" @click="goToHomePage()">è¿”å›ä¸»é¡µ</text>
    </div>

    <!-- Save Overlay -->
    <div class="overlay save-load-overlay" if="{{ recoveryMode === 1 }}">
      <scroll scroll-y="true" bounces="true" class="save-load-scroll">
        <text class="save-load-title">é•¿æŒ‰åˆ é™¤ï¼Œç‚¹å‡»è¦†ç›– (ç¬¬1ä¸ªä¸ºå¿«å­˜)</text> <!-- Indicate quick save slot -->
        <text class="save-load-slot {{ $idx === 0 ? 'quick-save-slot' : '' }}" for="{{ (index, slot) in recoveryData }}" @click="saveRecoveryData(index)" @longpress="deleteRecoveryData(index)">å­˜æ¡£ {{ index + 1 }}</text>
        <text class="save-load-slot save-load-new" @click="saveRecoveryData('new')">+</text>
      </scroll>
       <text class="save-load-close-button" @click="closeRecoveryOverlay">å…³é—­</text>
    </div>

    <!-- Load Overlay -->
    <div class="overlay save-load-overlay" if="{{ recoveryMode === 2 }}">
      <scroll scroll-y="true" bounces="true" class="save-load-scroll">
        <text class="save-load-title">ç‚¹å‡»è¯»å–å­˜æ¡£ (ç¬¬1ä¸ªä¸ºå¿«å­˜)</text> <!-- Indicate quick save slot -->
        <text class="save-load-slot {{ $idx === 0 ? 'quick-save-slot' : '' }}" for="{{ (index, slot) in recoveryData }}" @click="loadRecoveryData(index)">å­˜æ¡£ {{ index + 1 }}</text>
         <text class="save-load-empty" if="{{!recoveryData || recoveryData.length === 0}}">è¿˜æ²¡æœ‰å­˜æ¡£å“¦</text>
      </scroll>
       <text class="save-load-close-button" @click="closeRecoveryOverlay">å…³é—­</text>
    </div>

    <!-- End Game Overlay -->
    <div class="overlay end-game-overlay" if="{{ achievedEnding }}">
      <text class="end-game-title">è¾¾æˆç»“å±€ï¼š</text>
      <text class="end-game-name">{{ achievedEnding }}</text>
      <text class="end-game-back" @click="goToHomePage">è¿”å›ä¸»é¡µ</text>
    </div>
  </div>
</template>

<style>
  /* === Base & Dialogue Styles === */
  .page-container { width: 336px; height: 480px; position: relative; background-color: #000000; overflow: hidden; }
  .dialogue-layer { width: 100%; height: 100%; position: relative; background-color: #000000; }
  .dialogue-background { width: 100%; height: 100%; object-fit: cover; }
  .scene-image { position: absolute; }
  .dialogue-ui { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; }
  .dialogue-text-bg { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; }
  /* è§’è‰²åæ˜¾ç¤ºä½ç½®è°ƒäº†ä¸‹ï¼Œä¹‹å‰æœ‰ç‚¹åä¸‹ï¼Œç°åœ¨åº”è¯¥æ›´èˆ’æœäº†ã€‚è¿™å—UIçœŸæ˜¯ç»†èŠ‚æ´»å„¿å•Š~ */
  .dialogue-character { position: absolute; bottom: 130px; left: 20px; font-size: 28px; color: #ffffff; font-weight: bold; }
  /* å¯¹è¯æ–‡æœ¬çš„æ»šåŠ¨åŒºåŸŸä¹Ÿåšäº†è°ƒæ•´ï¼Œç»™è§’è‰²åç•™å‡ºè¶³å¤Ÿçš„ç©ºé—´ã€‚ */
  .dialogue-scroll { position: absolute; bottom: 10px; left: 8px; right: 8px; height: 115px; overflow: hidden; flex-wrap: wrap; }
  .dialogue-text { color: #ffffff; font-weight: bold; width: 100%; text-align: left; }

  /* === Overlay Base === */
  .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.5); flex-direction: column; }

  /* === Choices Overlay & Button === */
  /* åˆ†æ”¯é€‰æ‹©çš„é®ç½©å±‚ï¼Œä¹‹å‰è¿™é‡Œå¤šåŠ äº†ä¸ªposition: relative;å¯¼è‡´å®ƒæ²¡æ³•é“ºæ»¡å…¨å±ï¼ŒæŒ‰é’®ä½ç½®å°±è·‘åäº†ã€‚ç°åœ¨ç§»é™¤äº†ï¼Œåº”è¯¥èƒ½æ­£å¸¸è¦†ç›–å¹¶å±…ä¸­æ˜¾ç¤ºäº†ã€‚ */
  .choices-overlay {
    background-color: transparent;
    /* Keep justification/alignment defaults (center) or adjust if needed */
    /* justify-content: flex-start; */
    /* align-items: flex-start; */
    /* position: relative; */ /* Needed for absolute positioning of children */
  }
  .choice-button {
    position: absolute; /* Position relative to overlay */
    width: 250px;
    height: 61px; /* Adjust height? */
    /* Recalculate left for centering: (container_width - element_width) / 2 */
    left: 43px; /* (336 - 250) / 2 = 43 */
    /* Top is calculated inline */
    background-color: rgba(80, 192, 231, 0.85); /* Slightly more opaque */
    color: #ffffff;
    font-size: 22px; /* Slightly smaller if needed */
    font-weight: bold;
    text-align: center;
    padding: 8px;  /* Adjusted padding */
    display: flex; /* Use flex to center text vertically & horizontally */
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    /* margin-bottom removed as top is absolute */
  }

  /* === Menu Overlay & Buttons === */
  .menu-overlay { background-color: rgba(255, 255, 255, 0.95); padding-top: 15px; padding-bottom: 15px; /* Add vertical padding */}
  .menu-button {
    width: 230px; /* Slightly narrower */
    height: 50px; /* Slightly shorter */
    background-color: rgba(80, 192, 231, 0.8);
    color: #ffffff;
    font-size: 22px; /* Smaller font */
    font-weight: bold;
    text-align: center;
    margin-bottom: 12px; /* Reduced margin */
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    flex-shrink: 0; /* Prevent shrinking in flex column */
  }
  .quick-save-button { /* Optional different style for quick save */
      background-color: rgba(100, 210, 100, 0.8); /* Greenish */
  }

  /* === Save/Load Overlay === */
  .save-load-overlay { background-color: rgba(255, 255, 255, 0.95); justify-content: flex-start; padding: 15px; }
  .save-load-scroll { width: 100%; height: 82%; /* Adjusted height */ display: flex; flex-direction: column; align-items: center; margin-bottom: 5px; }
  .save-load-title { font-size: 18px; /* Smaller title */ color: #333333; margin-bottom: 15px; font-weight: bold; flex-shrink: 0; text-align: center; }
  .save-load-slot { width: 95%; max-width: 280px; height: 50px; background-color: rgba(80, 192, 231, 0.7); color: #ffffff; font-size: 20px; font-weight: bold; text-align: center; margin-bottom: 12px; display: flex; justify-content: center; align-items: center; border-radius: 8px; flex-shrink: 0; }
  .quick-save-slot { border: 2px solid #ffd700; /* Highlight quick save slot */ }
  .save-load-new { font-size: 30px; background-color: rgba(100, 210, 100, 0.8); }
  .save-load-empty { margin-top: 20px; font-size: 18px; color: #888888; flex-shrink: 0; }
  .save-load-close-button { font-size: 18px; color: #007aff; padding: 8px; margin-top: auto; flex-shrink: 0; }

  /* === End Game Overlay === */
  .end-game-overlay { background-color: rgba(255, 255, 255, 0.95); }
  .end-game-title { font-size: 28px; color: #333333; margin-bottom: 10px; }
  .end-game-name { font-size: 32px; color: #000000; font-weight: bold; margin-bottom: 40px; text-align: center; }
  .end-game-back { font-size: 24px; color: #007aff; padding: 10px; }
</style>

<script>
  import router from '@system.router';
  import storage from '@system.storage';
  import prompt from '@system.prompt';
  import file from '@system.file';

  const STORAGE_KEYS = { RECOVERY_DATA: 'recoveryData', SETTINGS: 'settings', FIN_STATUS: 'fin' };
  const DEFAULT_BG = 'bg.png';
  const ENDING_TYPES = { HE: "Happy Ending", BE: "Bad Ending" };
  const RECOVERY_MODE_NONE = 0; const RECOVERY_MODE_SAVE = 1; const RECOVERY_MODE_LOAD = 2;
  const QUICK_SAVE_SLOT_INDEX = 0; // Use slot 0 for quick save/load

  export default {
    private: {
      // State...
      gameData: { scenes: [], }, chapter: 0, currentScene: 0, currentDialogue: 0, choicesMade: [],
      chapterList: ['b999','b101','b102','b103','b111','b112','b113','b114','b121','b122','b123','b124','b200','b201','b202','b203','b204','b205','b206','b207','b301','b302','b303','b304','b401','b402','b403','b404','b405','b406','b407','b501','b601','b701'],
      currentBackground: DEFAULT_BG, characterName: '', displayedText: '',
      isMenuVisible: false, recoveryMode: RECOVERY_MODE_NONE, achievedEnding: '',
      fullDialogueText: '', typingIndex: 0, typingTimeoutId: null, canProgress: true,
      settings: { textSpeed: 40, textSize: 22 }, recoveryData: [],
      loadOnInitData: null, isDataLoading: true,
    },
    computed: {
        showSceneImage() { return !this.isDataLoading && this.gameData.scenes && this.gameData.scenes.length > this.currentScene && this.gameData.scenes[this.currentScene]?.Img !== undefined; },
        showDialogueUI() { if (this.isDataLoading || !this.gameData.scenes || this.gameData.scenes.length <= this.currentScene) return false; const scene = this.gameData.scenes[this.currentScene]; return this.currentBackground !== DEFAULT_BG && !scene?.choices; },
        showChoicesUI() { if (this.isDataLoading || !this.gameData.scenes || this.gameData.scenes.length <= this.currentScene) return false; const scene = this.gameData.scenes[this.currentScene]; const hasChoices = !!scene?.choices && scene.choices.length > 0; return hasChoices; }
    },

    onInit() {
        this.isDataLoading = true; console.log("[Detail] onInit");
        if (this.load) { this.loadOnInitData = this.load; } else { this.loadOnInitData = { type: 'chapter', index: 0 }; }
        this.loadSettingsAndRecovery().then(() => { this.startGameFromInitData(); this.isDataLoading = false; })
            .catch(err => { console.error("[Detail] Init load fail:", err); this.isDataLoading = false; });
    },
    onDestroy() { this.clearTypingTimeout(); },

    // --- æ•°æ®åŠ è½½å™¨ï¼šåŠ è½½è®¾ç½®å’Œå­˜æ¡£æ•°æ® ---
    loadSettingsAndRecovery() {
        return new Promise((resolve, reject) => {
            let settingsLoaded = false; let recoveryLoaded = false;
            const check = () => { if (settingsLoaded && recoveryLoaded) resolve(); };
            storage.get({ key: STORAGE_KEYS.SETTINGS,
                success: (d) => { let s={}; if(d){try{s=JSON.parse(d);}catch(e){}} this.settings={...this.private.settings,...s}; console.log("[Detail] Settings loaded");},
                fail: (d,c) => { console.warn(`[Detail] Load settings fail: ${d}, ${c}`);},
                complete: () => { settingsLoaded = true; check(); } });
            storage.get({ key: STORAGE_KEYS.RECOVERY_DATA,
                success: (d) => { if(d){try{this.recoveryData=JSON.parse(d);}catch(e){this.recoveryData=[];}}else{this.recoveryData=[];} console.log(`[Detail] Recovery loaded: ${this.recoveryData.length}`);},
                fail: (d,c) => { console.warn(`[Detail] Load recovery fail: ${d}, ${c}`); this.recoveryData = []; },
                complete: () => { recoveryLoaded = true; check(); } });
        });
    },

    // --- æ¸¸æˆåˆå§‹åŒ– / é‡ç½®çŠ¶æ€ ---
    startGameFromInitData() {
        console.log("[Detail] startGameFromInitData:", JSON.stringify(this.loadOnInitData)); if (!this.loadOnInitData) return; this.resetGameState();
        const { type, index } = this.loadOnInitData;
        if (type === 'load' && index !== undefined && this.recoveryData[index]) { this.loadGameFromState(this.recoveryData[index]); }
        else if (type === 'TE') { this.chapter = 'TE'; this.loadChapterData(33); } else if (type === 'BE') { this.chapter = 'BE'; this.loadChapterData(32); }
        else if (type === 'chapter') { const chapterIndex = index !== undefined ? index : 0; this.chapter = chapterIndex; this.loadChapterData(this.chapter); }
        else { console.warn("[Detail] Unknown load type", this.loadOnInitData); this.chapter = 0; this.loadChapterData(0); }
    },
    resetGameState(preserveIndices = false) {
        console.log("[Detail] Resetting game state.", preserveIndices);
        this.isMenuVisible = false; this.recoveryMode = RECOVERY_MODE_NONE; this.achievedEnding = ''; this.clearTypingTimeout();
        if (!preserveIndices) { this.currentScene = 0; this.currentDialogue = 0; this.choicesMade = []; }
    },

     // --- ç« èŠ‚/åœºæ™¯åŠ è½½é€»è¾‘ ---
     loadChapterData(chapterId) {
         console.log(`[Detail] Request load chapter: ${chapterId}`); let index = -1; let special = false;
         if (chapterId === 'BE') { this.chapter = 'BE'; index = 32; special = true; } else if (chapterId === 'TE') { this.chapter = 'TE'; index = 33; special = true; }
         else if (typeof chapterId === 'number') { this.chapter = chapterId; index = chapterId; special = false; }
         else { console.error(`[Detail] Invalid chapter ID: ${chapterId}`); index = 0; this.chapter = 0; }
         console.log(`[Detail] Effective load: Chapter='${this.chapter}', Index=${index}, Special=${special}`); this.loadChapterDataInternal(index);
     },
     loadChapterDataInternal(index) {
         if (typeof index !== 'number' || index < 0 || index >= this.chapterList.length) { console.error(`[Detail] Internal invalid index ${index}`); if(index !== 0) { this.loadChapterDataInternal(0); } else { router.back(); } return; }
         const filename = this.chapterList[index];
         // Vela ç³»ç»Ÿçš„ `JSON.parse` ç¼–è¯‘å‡ºæ¥ä¹‹åæ”¾çœŸæœºä¸Šåªè§£æ `.txt`ï¼Œè®¤éƒ½ä¸è®¤ `.json`...
         // æˆ‘æ•¢è¯´å¼€å‘ Vela å¿«åº”ç”¨ç¼–è¯‘å™¨çš„è€å“¥ç»å¯¹æ²¡å¹²è¿‡å…¨æ ˆï¼Œç”šè‡³å‰ç«¯éƒ½æ²¡æ€ä¹ˆå¹²è¿‡ï¼Œä½ çŒœå®ƒä¸ºä»€ä¹ˆä¸å« `TXT.parse`ï¼ŸğŸ¤·â€â™€ï¸
         const uri = `/common/content/${filename}.txt`; // ä¹‹å‰æ˜¯.jsonï¼Œç°åœ¨æ”¹æˆ.txtæ‰èƒ½åœ¨çœŸæœºä¸Šè·‘èµ·æ¥ã€‚
         console.log(`[Detail] Reading: ${uri}`);
         this.gameData.scenes = []; this.choicesMade = []; // Reset here
         console.log(`[Detail] Indices before file read: ${this.currentScene}/${this.currentDialogue}`);
         file.readText({ uri: uri,
             success: (d) => { if (d && d.text) { try { this.gameData.scenes = JSON.parse(d.text); console.log(`[Detail] Parsed ${filename}: ${this.gameData.scenes.length} scenes.`); this.applyCurrentSceneState(); } catch (e) { console.error(`[Detail] Parse fail ${uri}:`, e); router.back(); } } else { console.error(`[Detail] Empty file: ${uri}`); router.back(); } },
             fail: (d, c) => { console.error(`[Detail] Read fail ${uri}: ${d}, ${c}`); router.back(); },
             complete: () => { console.log(`[Detail] File read complete ${uri}`); }
         });
     },
    applyCurrentSceneState() {
        console.log(`[Detail] Applying state: S=${this.currentScene}, D=${this.currentDialogue}`);
        if (this.currentScene < 0 || this.currentScene >= this.gameData.scenes.length) { console.error(`[Detail] Invalid Scene ${this.currentScene}, resetting.`); this.currentScene = 0; this.currentDialogue = 0; }
        const scene = this.gameData.scenes[this.currentScene]; if (scene && scene.dialogues && (this.currentDialogue < 0 || this.currentDialogue >= scene.dialogues.length)) { console.warn(`[Detail] Invalid Dialogue ${this.currentDialogue}, resetting.`); this.currentDialogue = 0; }
        this.loadScene(this.currentScene);
    },

    // --- åœºæ™¯/å¯¹è¯æ¨è¿›é€»è¾‘ ---
    loadScene(sceneIndex) {
        console.log(`[Detail] --- Loading Scene Index: ${sceneIndex} ---`); this.clearTypingTimeout();
        if (!this.gameData?.scenes || sceneIndex < 0 || sceneIndex >= this.gameData.scenes.length) { console.error(`[Detail] loadScene invalid index ${sceneIndex}`); this.handleChapterEnd(); return; }
        this.currentScene = sceneIndex; const scene = this.gameData.scenes[this.currentScene]; console.log(`[Detail] Scene ${sceneIndex} Data: ${JSON.stringify(scene)}`);
        if (!scene) { console.error("[Detail] Scene null."); this.handleChapterEnd(); return; }
        this.currentBackground = scene.background || DEFAULT_BG;
        if (scene.choices?.length > 0) { console.log(`[Detail] Scene ${sceneIndex}: Choices.`); this.characterName = ''; this.displayedText = ''; this.canProgress = false; }
        else if (scene.dialogues?.length > 0) { console.log(`[Detail] Scene ${sceneIndex}: Dialogues. Loading ${this.currentDialogue}.`); if (this.currentDialogue < 0 || this.currentDialogue >= scene.dialogues.length) { this.currentDialogue = 0; } this.loadDialogue(scene.dialogues[this.currentDialogue]); }
        else { console.log(`[Detail] Scene ${sceneIndex}: Empty. Proceeding.`); this.handleDialogueEnd(); }
    },
    loadDialogue(dialogue) {
        if (!dialogue) { console.error("[Detail] loadDialogue: null."); this.handleDialogueEnd(); return; } console.log(`[Detail] Loading dialogue: '${(dialogue.text || "").substring(0,20)}...'`);
        if(this.showDialogueUI) { this.scrollToTop(); } this.clearTypingTimeout(); this.characterName = dialogue.character || '';
        this.fullDialogueText = dialogue.text || ''; this.displayedText = ''; this.typingIndex = 0; this.canProgress = false; this.startTypingEffect();
    },
    startTypingEffect() {
        if (this.isMenuVisible || this.recoveryMode !== RECOVERY_MODE_NONE || this.achievedEnding || this.showChoicesUI) { this.clearTypingTimeout(); return; } if (this.typingIndex < this.fullDialogueText.length) { this.displayedText += this.fullDialogueText.charAt(this.typingIndex); this.typingIndex++; this.typingTimeoutId = setTimeout(() => { this.startTypingEffect(); }, this.settings.textSpeed); } else { this.canProgress = true; this.typingTimeoutId = null; }
    },

    // --- ç©å®¶æ“ä½œä¸æ¸¸æˆæµç¨‹æ§åˆ¶ ---
    nextDialogue() {
        console.log(`[Detail] nextDialogue clicked. Progress=${this.canProgress}`); if (this.isMenuVisible || this.recoveryMode !== RECOVERY_MODE_NONE || this.achievedEnding || this.showChoicesUI) { return; }
        if (!this.canProgress && this.typingTimeoutId) { this.clearTypingTimeout(); this.displayedText = this.fullDialogueText; this.canProgress = true; return; }
        if (this.canProgress) { const scene = this.gameData?.scenes?.[this.currentScene]; if (!scene?.dialogues || this.currentDialogue >= scene.dialogues.length - 1) { this.handleDialogueEnd(); } else { this.currentDialogue++; this.loadDialogue(scene.dialogues[this.currentDialogue]); } }
    },
    handleDialogueEnd() {
        console.log(`[Detail] handleDialogueEnd: S=${this.currentScene}, D=${this.currentDialogue}`); const scene = this.gameData?.scenes?.[this.currentScene];
        const source = scene?.dialogues?.[this.currentDialogue] || scene; if (!source) { this.handleSceneEnd(); return; }
        if (source.END !== undefined) { this.triggerEnding(source.END); } else if (source.branch !== undefined) { this.evaluateBranch(source.branch); }
        else if (source.toScenes !== undefined) { const jump = parseInt(source.toScenes, 10); if (!isNaN(jump)) { this.currentDialogue = 0; this.loadScene(this.currentScene + jump); } else { this.handleSceneEnd(); } }
        else { this.handleSceneEnd(); }
    },
    handleSceneEnd() {
        console.log(`[Detail] handleSceneEnd: S=${this.currentScene}`); if (!this.gameData?.scenes) { this.goToHomePage(); return; }
        if (this.currentScene < this.gameData.scenes.length - 1) { this.currentDialogue = 0; this.loadScene(this.currentScene + 1); } else { this.handleChapterEnd(); }
    },
    handleChapterEnd() {
        console.log(`[Detail] handleChapterEnd: Ch=${this.chapter}`); this.currentBackground = DEFAULT_BG; this.characterName=''; this.displayedText=''; this.canProgress=false;
        let nextIndex = -1; if (typeof this.chapter === 'number') { nextIndex = this.chapter + 1; } else { setTimeout(() => this.goToHomePage(), 1500); return; }
        if (nextIndex >= 0 && nextIndex < this.chapterList.length) { console.log(`[Detail] Loading next Ch index: ${nextIndex}`); this.currentScene=0; this.currentDialogue=0; this.choicesMade=[]; setTimeout(() => this.loadChapterData(nextIndex), 1500); }
        else { console.log("[Detail] Game end."); setTimeout(() => this.goToHomePage(), 1500); }
    },
    evaluateBranch(branchData) {
        console.log("[Detail] Evaluating branch:", branchData); if (!branchData || !branchData.choices || branchData.toChapter === undefined) { this.handleSceneEnd(); return; } const match = JSON.stringify(this.choicesMade) === JSON.stringify(branchData.choices);
        let target = match ? branchData.toChapter : branchData.elseChapter; if (target === undefined && !match) { this.handleSceneEnd(); return; }
        this.currentScene=0; this.currentDialogue=0; this.choicesMade=[]; this.loadChapterData(target);
    },
    selectChoice(index) {
        const scene = this.gameData?.scenes?.[this.currentScene]; if (!scene?.choices?.[index]) { return; } const choice = scene.choices[index]; console.log(`[Detail] Choice ${index}: '${choice.text}'`); this.choicesMade.push(index);
        const offset = choice.nextScene; if (typeof offset !== 'number') { this.handleSceneEnd(); return; } this.currentDialogue = 0; this.loadScene(this.currentScene + offset);
    },

    // --- èœå•ä¸é®ç½©å±‚æ§åˆ¶ ---
    handleSwipeBack(event) {
       // å³æ»‘å‘¼å‡ºèœå•çš„é€»è¾‘ï¼Œè¿™é‡Œåšäº†ä¸ªå°ä¼˜åŒ–ï¼Œç¡®ä¿åœ¨ç‰¹å®šçŠ¶æ€ä¸‹æ‰èƒ½å‘¼å‡ºï¼Œé¿å…è¯¯è§¦ã€‚ç”¨æˆ·ä½“éªŒå˜›ï¼Œå¾—è€ƒè™‘å‘¨å…¨ã€‚
       if (event.direction === 'right' && !this.isMenuVisible && this.recoveryMode === RECOVERY_MODE_NONE && !this.achievedEnding && !this.showChoicesUI && this.canProgress && !this.isDataLoading ) { this.isMenuVisible = true; this.clearTypingTimeout(); this.canProgress = false; }
    },
    closeMenu() {
       this.isMenuVisible = false; this.canProgress = !this.showChoicesUI && !this.achievedEnding && !this.isDataLoading;
    },
    goToHomePage() { router.replace({ uri: "/pages/index" }); },
    toRecoveryPage(mode) {
        console.log(`[Detail] Opening Recovery: Mode=${mode}`); if (mode === RECOVERY_MODE_LOAD && (!this.recoveryData || this.recoveryData.length === 0)) { prompt.showToast({ message: "æ²¡æœ‰å­˜æ¡£" }); return; }
        this.recoveryMode = mode; this.isMenuVisible = false;
    },
    closeRecoveryOverlay() {
        console.log("[Detail] Closing Recovery Overlay."); this.recoveryMode = RECOVERY_MODE_NONE; this.isMenuVisible = true; this.canProgress = false;
    },

    // === å¿«é€Ÿå­˜æ¡£ / è¯»æ¡£åŠŸèƒ½ ===
    quickSave() {
        console.log("[Detail] Action: Quick Save");
        if (this.isDataLoading || this.achievedEnding) { prompt.showToast({message: "å½“å‰æ— æ³•å¿«é€Ÿå­˜æ¡£"}); return; }

        const currentState = { chapter: this.chapter, currentScene: this.currentScene, currentDialogue: this.currentDialogue, choicesMade: [...this.choicesMade], timestamp: new Date().toISOString() };

        // ç¡®ä¿ recoveryData æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œä¸ç„¶ä¼šæŠ¥é”™ã€‚
        if (!Array.isArray(this.recoveryData)) { this.recoveryData = []; }

        // è¦†ç›–æˆ–æ·»åŠ åˆ°æ§½ä½0ï¼Œè¿™ä¸ªæ˜¯å¿«é€Ÿå­˜æ¡£çš„ä¸“å±ä½ç½®ã€‚
        this.recoveryData[QUICK_SAVE_SLOT_INDEX] = currentState;
        this.persistRecoveryData(); // ä¿å­˜æ•´ä¸ªå­˜æ¡£åˆ—è¡¨
        prompt.showToast({ message: "å¿«é€Ÿå­˜æ¡£æˆåŠŸ (å­˜æ¡£ 1)" });
        this.closeMenu(); // å¿«é€Ÿæ“ä½œåè‡ªåŠ¨å…³é—­èœå•ï¼Œæ–¹ä¾¿ç©å®¶ç»§ç»­æ¸¸æˆã€‚
    },

    quickLoad() {
        console.log("[Detail] Action: Quick Load");
        if (!this.recoveryData || this.recoveryData.length <= QUICK_SAVE_SLOT_INDEX || !this.recoveryData[QUICK_SAVE_SLOT_INDEX]) {
             prompt.showToast({ message: "æ²¡æœ‰å¿«é€Ÿå­˜æ¡£å¯è¯»" });
             return;
        }
        if (this.isDataLoading || this.achievedEnding) { prompt.showToast({message: "å½“å‰æ— æ³•å¿«é€Ÿè¯»æ¡£"}); return; }

        const saveData = this.recoveryData[QUICK_SAVE_SLOT_INDEX];
        prompt.showToast({ message: "è¯»å–å¿«é€Ÿå­˜æ¡£..." });
        this.isMenuVisible = false; // ç¡®ä¿èœå•å…³é—­
        this.recoveryMode = RECOVERY_MODE_NONE; // ç¡®ä¿å­˜æ¡£/è¯»æ¡£ç•Œé¢å…³é—­
        this.loadGameFromState(saveData); // åŠ è½½å­˜æ¡£æ•°æ®
    },
    // === å¿«é€Ÿå­˜æ¡£ / è¯»æ¡£åŠŸèƒ½ç»“æŸ ===

    // --- å¸¸è§„å­˜æ¡£/è¯»æ¡£/åˆ é™¤é€»è¾‘ ---
    saveRecoveryData(indexOrNew) {
        console.log(`[Detail] saveRecoveryData: Target=${indexOrNew}`); const state = { chapter: this.chapter, currentScene: this.currentScene, currentDialogue: this.currentDialogue, choicesMade: [...this.choicesMade], timestamp: new Date().toISOString() };
        if (indexOrNew === 'new') { if (this.recoveryData.length >= 10) { prompt.showToast({ message: 'å­˜æ¡£å·²æ»¡' }); return; } this.recoveryData.push(state); prompt.showToast({ message: 'ä¿å­˜æˆåŠŸ' }); }
        else if (typeof indexOrNew === 'number' && indexOrNew >= 0 && indexOrNew < this.recoveryData.length) { this.recoveryData[indexOrNew] = state; prompt.showToast({ message: 'è¦†ç›–æˆåŠŸ' }); }
        else { prompt.showToast({ message: 'ä¿å­˜å¤±è´¥' }); return; } this.persistRecoveryData(); this.closeRecoveryOverlay();
    },
    deleteRecoveryData(index) {
        prompt.showDialog({ title: 'ç¡®è®¤åˆ é™¤', message: `ç¡®å®šè¦åˆ é™¤å­˜æ¡£ ${index + 1} å—ï¼Ÿ`, buttons: [{ text: 'å–æ¶ˆ'}, { text: 'åˆ é™¤', color: '#DD2C00' }],
            success: (d) => { if (d.index === 1) { if (index >= 0 && index < this.recoveryData.length) { this.recoveryData.splice(index, 1); this.persistRecoveryData(); prompt.showToast({ message: 'åˆ é™¤æˆåŠŸ' }); } else { prompt.showToast({ message: 'åˆ é™¤å¤±è´¥' }); } } else { prompt.showToast({ message: 'å·²å–æ¶ˆ' }); } },
            fail: (err) => { prompt.showToast({ message: 'æ“ä½œå¤±è´¥' }); console.error("Delete Dialog fail:", err); }, complete: () => {} });
    },
    loadRecoveryData(index) {
        console.log(`[Detail] Request load idx: ${index}`); if (index >= 0 && index < this.recoveryData.length) { const saveData = this.recoveryData[index]; prompt.showToast({ message: `è¯»å–å­˜æ¡£ ${index + 1}...` }); this.recoveryMode = RECOVERY_MODE_NONE; this.isMenuVisible = false; this.loadGameFromState(saveData); } else { prompt.showToast({ message: 'æ— æ•ˆå­˜æ¡£' }); }
    },
    loadGameFromState(stateData) {
        if (!stateData) return; console.log("[Detail] Loading state:", JSON.stringify(stateData)); this.isDataLoading = true; this.clearTypingTimeout(); this.resetGameState(true);
        this.chapter = stateData.chapter; this.currentScene = stateData.currentScene; this.currentDialogue = stateData.currentDialogue; this.choicesMade = stateData.choicesMade ? [...stateData.choicesMade] : [];
        console.log(`[Detail] State restored: Ch=${this.chapter}`); this.loadChapterData(this.chapter);
        setTimeout(() => { this.isDataLoading = false; this.canProgress = !this.showChoicesUI && !this.achievedEnding && !this.isMenuVisible; console.log(`[Detail] Load complete. Progress=${this.canProgress}`); }, 200);
    },
    persistRecoveryData() {
        console.log("[Detail] Persisting recovery..."); try { const v = JSON.stringify(this.recoveryData); storage.set({ key: STORAGE_KEYS.RECOVERY_DATA, value: v, success: () => { console.log("[Detail] Recovery saved."); }, fail: (d, c) => { console.error(`Save recovery fail:${d},${c}`); prompt.showToast({ message: `å­˜æ¡£åˆ—è¡¨ä¿å­˜å¤±è´¥` }); }, complete: () => {} }); } catch (e) { console.error("Stringify recovery fail:", e); prompt.showToast({ message: 'å­˜æ¡£æ•°æ®å¼‚å¸¸' }); }
    },

    // --- è·³è¿‡ / ç»“å±€ / å·¥å…·å‡½æ•° ---
    skipScene() {
        console.log("[Detail] Skip Scene action"); if (this.isDataLoading || this.showChoicesUI || this.achievedEnding) { prompt.showToast({ message: 'å½“å‰æ— æ³•è·³è¿‡' }); this.closeMenu(); return; } const scene = this.gameData?.scenes?.[this.currentScene]; const lastDialogue = scene?.dialogues?.slice(-1)?.[0]; const skippable = !( scene?.choices || lastDialogue?.END || lastDialogue?.branch || lastDialogue?.toScenes ); const lastScene = this.currentScene >= (this.gameData?.scenes?.length || 0) - 1; if (skippable && !lastScene) { prompt.showToast({ message: "è·³è¿‡åœºæ™¯" }); this.closeMenu(); this.clearTypingTimeout(); this.currentDialogue = 0; this.loadScene (this.currentScene + 1); } else { prompt.showToast({ message: 'æ— æ³•è·³è¿‡æ­¤åœºæ™¯' }); this.closeMenu(); }
    },
    skipCurrentChapter() {
         console.log("[Detail] Skip Chapter action"); if (this.isDataLoading || this.achievedEnding) { prompt.showToast({ message: 'å½“å‰æ— æ³•è·³è¿‡' }); this.closeMenu(); return; } const noSkip = [2, 19, 25, 26]; const endings = ['TE', 'BE']; const lastNum = 31; const cant = noSkip.includes(this.chapter) || endings.includes(this.chapter) || (typeof this.chapter === 'number' && this.chapter >= lastNum); if (cant) { prompt.showToast({ message: 'æ­¤ç« èŠ‚æ— æ³•è·³è¿‡' }); this.closeMenu(); } else if (typeof this.chapter === 'number') { prompt.showToast({ message: "è·³è¿‡ç« èŠ‚..." }); this.closeMenu(); this.clearTypingTimeout(); this.handleChapterEnd(); } else { this.closeMenu(); }
     },
     triggerEnding(endingName) {
         if (this.achievedEnding) return; console.log(`[Detail] Trigger Ending: ${endingName}`); this.achievedEnding = endingName; this.updateFinStatus(endingName); this.canProgress = false; this.clearTypingTimeout(); this.isMenuVisible = false; this.recoveryMode = RECOVERY_MODE_NONE; prompt.showToast({message: `è¾¾æˆç»“å±€ï¼š${endingName}`})
     },
     updateFinStatus(endingName) {
         storage.get({ key: STORAGE_KEYS.FIN_STATUS, success: (d) => { let s = { HE: false, BE: false, ...(d ? JSON.parse(d) : {}) }; if (endingName === ENDING_TYPES.HE) s.HE = true; else if (endingName === ENDING_TYPES.BE) s.BE = true; storage.set({ key: STORAGE_KEYS.FIN_STATUS, value: JSON.stringify(s), success: () => {}, fail: ()=>{}, complete: () => {} }); }, fail: ()=>{}, complete: () => {} });
     },
    clearTypingTimeout() { if (this.typingTimeoutId) { clearTimeout(this.typingTimeoutId); this.typingTimeoutId = null; } },
    scrollToTop() { try { this.$element('dialogueScroll')?.scrollTo({ y: 0, smooth: false }); } catch (e) {} },
  }
</script>
