<template>
  <!-- Root container -->
  <div class="page-container" @swipe="handleSwipeBack">

    <!-- Dialogue Layer -->
    <div class="dialogue-layer" @click="nextDialogue">
      <image class="dialogue-background" src="/common/{{ currentBackground }}"></image>
      <image class="scene-image" src="/common/{{ gameData.scenes[currentScene].Img }}" style="top:{{gameData.scenes[currentScene].ImgTop}}px; left:{{gameData.scenes[currentScene].ImgLeft}}px;" if="{{ showSceneImage }}"></image>
      <div class="dialogue-ui" if="{{ showDialogueUI }}">
        <image class="dialogue-text-bg" src="/common/text_bg.png"></image>
        <text class="dialogue-character">{{ characterName }}</text>
        <scroll scroll-y="true" bounces="true" class="dialogue-scroll" id="dialogueScroll">
          <!-- Ensure style binding is correct based on settings -->
          <text class="dialogue-text" style="font-size: {{ settings.textSize }}px;">{{ displayedText }}</text>
        </scroll>
      </div>
    </div>

    <!-- Choices Overlay (Conditional Rendering) -->
    <div class="overlay choices-overlay" if="{{ showChoicesUI }}">
      <text class="choice-button" for="{{ (index, choice) in gameData.scenes[currentScene].choices }}" style="top: {{ 100 + index * 110 }}px;" @click="selectChoice(index)">{{ choice.text }}</text>
    </div>

    <!-- Menu Overlay (Conditional Rendering) -->
    <div class="overlay menu-overlay" if="{{ isMenuVisible }}">
      <text class="menu-button" @click="toRecoveryPage(1)">保存</text> <!-- 1 = Save -->
      <text class="menu-button" @click="toRecoveryPage(2)">加载</text> <!-- 2 = Load -->
      <text class="menu-button" @click="skipScene()">跳过场景</text>
      <text class="menu-button" @click="skipCurrentChapter()">跳过章节</text>
      <text class="menu-button" @click="closeMenu()">返回</text>
      <text class="menu-button" @click="goToHomePage()">返回主页</text>
    </div>

    <!-- Save Overlay (Conditional Rendering) -->
    <div class="overlay save-load-overlay" if="{{ recoveryMode === 1 }}"> <!-- Check against 1 -->
      <scroll scroll-y="true" bounces="true" class="save-load-scroll">
        <text class="save-load-title">长按删除，点击覆盖</text>
        <text class="save-load-slot" for="{{ (index, slot) in recoveryData }}" @click="saveRecoveryData(index)" @longpress="deleteRecoveryData(index)">存档 {{ index + 1 }}</text>
        <text class="save-load-slot save-load-new" @click="saveRecoveryData('new')">+</text>
      </scroll>
      <!-- Add a close button for Save overlay as swipe isn't implemented -->
       <text class="save-load-close-button" @click="closeRecoveryOverlay">关闭</text>
    </div>

    <!-- Load Overlay (Conditional Rendering) -->
    <div class="overlay save-load-overlay" if="{{ recoveryMode === 2 }}"> <!-- Check against 2 -->
      <scroll scroll-y="true" bounces="true" class="save-load-scroll">
        <text class="save-load-title">点击读取存档</text>
        <text class="save-load-slot" for="{{ (index, slot) in recoveryData }}" @click="loadRecoveryData(index)">存档 {{ index + 1 }}</text>
         <text class="save-load-empty" if="{{!recoveryData || recoveryData.length === 0}}">还没有存档哦</text>
      </scroll>
       <!-- Add a close button for Load overlay -->
       <text class="save-load-close-button" @click="closeRecoveryOverlay">关闭</text>
    </div>

    <!-- End Game Overlay (Conditional Rendering) -->
    <div class="overlay end-game-overlay" if="{{ achievedEnding }}">
      <text class="end-game-title">达成结局：</text>
      <text class="end-game-name">{{ achievedEnding }}</text>
      <text class="end-game-back" @click="goToHomePage">返回主页</text>
    </div>
  </div>
</template>

<style>
  /* Styles remain the same as previous version (no :active, zIndex, etc.) */
  .page-container { width: 336px; height: 480px; position: relative; background-color: #000000; overflow: hidden; }
  .dialogue-layer { width: 100%; height: 100%; position: relative; background-color: #000000; }
  .dialogue-background { width: 100%; height: 100%; object-fit: cover; }
  .scene-image { position: absolute; }
  .dialogue-ui { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; }
  .dialogue-text-bg { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; /* Give explicit height */ }
  .dialogue-character { position: absolute; bottom: 160px; /* Adjust based on text_bg height */ left: 8px; font-size: 28px; color: #ffffff; font-weight: bold; }
  .dialogue-scroll { position: absolute; bottom: 0px; left: 8px; right: 8px; height: 155px; /* Adjust based on text_bg height */ overflow: hidden; flex-wrap: wrap; }
  .dialogue-text { color: #ffffff; font-weight: bold; width: 100%; text-align: left; }
  .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.5); flex-direction: column; /* Default to column for easier control */}
  .choices-overlay { background-color: transparent; justify-content: flex-start; align-items: flex-start; position: relative; }
  .choice-button { position: absolute; width: 250px; height: 61px; left: 43px; background-color: rgba(80, 192, 231, 0.8); color: #ffffff; font-size: 24px; font-weight: bold; text-align: center; padding: 10px; display: flex; justify-content: center; align-items: center; border-radius: 8px; margin-bottom: 20px; }
  .menu-overlay { background-color: rgba(255, 255, 255, 0.95); } /* Remove flex specific overrides if base is column */
  .menu-button { width: 250px; height: 61px; background-color: rgba(80, 192, 231, 0.8); color: #ffffff; font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 20px; display: flex; justify-content: center; align-items: center; border-radius: 8px; }
  .save-load-overlay { background-color: rgba(255, 255, 255, 0.95); justify-content: flex-start; /* Align scroll/title to top */ padding: 20px; /* Add padding back */}
  .save-load-scroll { width: 100%; /* Take full width */ height: 80%; /* Limit height to allow space for close button */ display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; /* Space before close button */}
  .save-load-title { font-size: 20px; color: #333333; margin-bottom: 20px; font-weight: bold; flex-shrink: 0; /* Prevent shrinking */ }
  .save-load-slot { width: 95%; /* Slightly less wide */ max-width: 280px; height: 55px; background-color: rgba(80, 192, 231, 0.7); color: #ffffff; font-size: 22px; font-weight: bold; text-align: center; margin-bottom: 15px; display: flex; justify-content: center; align-items: center; border-radius: 8px; flex-shrink: 0; }
  .save-load-new { font-size: 30px; background-color: rgba(100, 210, 100, 0.8); }
  .save-load-empty { margin-top: 20px; /* Reduced margin */ font-size: 20px; color: #888888; flex-shrink: 0; }
   .save-load-close-button { margin-top: auto; /* Pushes to bottom if space allows, but scroll height limits it */ font-size: 20px; color: #007aff; padding: 10px; flex-shrink: 0; } /* Added close button style */
  .end-game-overlay { background-color: rgba(255, 255, 255, 0.95); } /* Remove flex specific overrides */
  .end-game-title { font-size: 28px; color: #333333; margin-bottom: 10px; }
  .end-game-name { font-size: 32px; color: #000000; font-weight: bold; margin-bottom: 40px; text-align: center; }
  .end-game-back { font-size: 24px; color: #007aff; padding: 10px; /* Easier to click */ }
</style>

<script>
  import router from '@system.router';
  import storage from '@system.storage';
  import prompt from '@system.prompt';
  import file from '@system.file';

  const STORAGE_KEYS = { RECOVERY_DATA: 'recoveryData', SETTINGS: 'settings', FIN_STATUS: 'fin' };
  const DEFAULT_BG = 'bg.png';
  const ENDING_TYPES = { HE: "Happy Ending", BE: "Bad Ending" };
  // Recovery Modes as Numbers
  const RECOVERY_MODE_NONE = 0;
  const RECOVERY_MODE_SAVE = 1;
  const RECOVERY_MODE_LOAD = 2;

  export default {
    private: {
      // Game State
      gameData: { scenes: [], }, chapter: 0, currentScene: 0, currentDialogue: 0, choicesMade: [],
      chapterList: ['b999','b101','b102','b103','b111','b112','b113','b114','b121','b122','b123','b124','b200','b201','b202','b203','b204','b205','b206','b207','b301','b302','b303','b304','b401','b402','b403','b404','b405','b406','b407','b501','b601','b701'],
      // Display State
      currentBackground: DEFAULT_BG, characterName: '', displayedText: '',
      isMenuVisible: false, recoveryMode: RECOVERY_MODE_NONE, // Use constant
      achievedEnding: '',
      // Typing Effect
      fullDialogueText: '', typingIndex: 0, typingTimeoutId: null, canProgress: true,
      // Settings & Saved Data
      settings: { textSpeed: 40, textSize: 22 }, recoveryData: [],
      loadOnInitData: null, // Data passed via router.push params
      isDataLoading: true, // Flag to prevent actions during initial load
    },

    computed: {
        showSceneImage() {
            // Only compute if data isn't loading and scenes exist
            return !this.isDataLoading && this.gameData.scenes && this.gameData.scenes.length > this.currentScene && this.gameData.scenes[this.currentScene]?.Img !== undefined;
        },
        showDialogueUI() {
            if (this.isDataLoading || !this.gameData.scenes || this.gameData.scenes.length <= this.currentScene) return false;
            const scene = this.gameData.scenes[this.currentScene];
            return this.currentBackground !== DEFAULT_BG && !scene?.choices;
        },
        showChoicesUI() {
             if (this.isDataLoading || !this.gameData.scenes || this.gameData.scenes.length <= this.currentScene) return false;
             const scene = this.gameData.scenes[this.currentScene];
             const hasChoices = !!scene?.choices && scene.choices.length > 0;
             // console.log(`[Detail] Computed showChoicesUI for scene ${this.currentScene}: ${hasChoices}`); // Keep log
             return hasChoices;
        }
    },

    // --- Lifecycle Hooks ---
    onInit() {
        this.isDataLoading = true; // Start in loading state
        console.log("[Detail] onInit: Page initializing.");
        if (this.load) { this.loadOnInitData = this.load; console.log("[Detail] Received Load Data:", this.loadOnInitData); }
        else { this.loadOnInitData = { type: 'chapter', index: 0 }; console.log("[Detail] No load data, defaulting to Chapter 0."); }
        // Start loading sequence
        this.loadSettingsAndRecovery().then(() => {
            console.log("[Detail] Initial settings and recovery loaded. Starting game logic.");
            this.startGameFromInitData();
             // Set loading to false AFTER game init sequence starts
            this.isDataLoading = false;
        }).catch(err => {
            console.error("[Detail] Error during initial data load:", err);
            prompt.showToast({ message: "初始数据加载失败" });
            this.isDataLoading = false; // Still unlock UI, may be broken
             // Consider routing back? router.back();
        });
    },

    onDestroy() {
        console.log("[Detail] onDestroy: Clearing timers.");
        this.clearTypingTimeout(); // Clean up timer
    },

    // --- Data Loading ---
    loadSettingsAndRecovery() {
        console.log("[Detail] Loading settings and recovery data...");
        return new Promise((resolve, reject) => {
            let settingsLoaded = false;
            let recoveryLoaded = false;

            const checkCompletion = () => {
                if (settingsLoaded && recoveryLoaded) {
                    resolve();
                }
            };

            // Load Settings
            storage.get({
                key: STORAGE_KEYS.SETTINGS,
                success: (data) => {
                    let loadedSettings = {};
                    if (data) { try { loadedSettings = JSON.parse(data); } catch (e) { console.error("[Detail] Parse settings failed:", e); } }
                    this.settings = { ...this.private.settings, ...loadedSettings }; // Use private defaults as base
                    console.log("[Detail] Settings loaded:", this.settings);
                },
                fail: (data, code) => { console.warn(`[Detail] Load settings fail: ${data}, ${code}`); /* Uses defaults */ },
                complete: () => { settingsLoaded = true; checkCompletion(); }
            });

            // Load Recovery Data
            storage.get({
                key: STORAGE_KEYS.RECOVERY_DATA,
                success: (data) => {
                    if (data) { try { this.recoveryData = JSON.parse(data); } catch (e) { console.error("[Detail] Parse recovery failed:", e); this.recoveryData = []; } }
                    else { this.recoveryData = []; }
                     console.log(`[Detail] Recovery loaded: ${this.recoveryData.length} slots`);
                },
                fail: (data, code) => { console.warn(`[Detail] Load recovery fail: ${data}, ${code}`); this.recoveryData = []; },
                complete: () => { recoveryLoaded = true; checkCompletion(); }
            });
        });
    },

    // --- Game Initialization & Chapter/Scene Loading ---
    startGameFromInitData() {
        console.log("[Detail] Starting game from init data:", JSON.stringify(this.loadOnInitData));
        if (!this.loadOnInitData) { /* Safety check */ return; }

        // Reset state for fresh start/load
        this.resetGameState();

        const { type, index } = this.loadOnInitData;

        if (type === 'load' && index !== undefined && this.recoveryData[index]) {
             console.log(`[Detail] Loading from save slot index: ${index}`);
             this.loadGameFromState(this.recoveryData[index]); // This handles chapter loading internally
        } else if (type === 'TE') {
             console.log("[Detail] Loading True Ending route.");
             this.chapter = 'TE'; // Set identifier *before* loading
             this.loadChapterData(33); // Load chapter by index
        } else if (type === 'BE') { // Handle BE explicitly if needed
             console.log("[Detail] Loading Bad Ending route.");
              this.chapter = 'BE'; // Set identifier *before* loading
             this.loadChapterData(32); // Load chapter by index
        } else if (type === 'chapter') {
             const chapterIndex = index !== undefined ? index : 0; // Default to 0 if index missing
             console.log(`[Detail] Loading chapter by index: ${chapterIndex}`);
             this.chapter = chapterIndex; // Set index
             this.loadChapterData(this.chapter);
        } else {
            console.warn("[Detail] Unknown load type or invalid data, defaulting Chapter 0.", JSON.stringify(this.loadOnInitData));
            this.chapter = 0;
            this.loadChapterData(this.chapter);
        }
    },

    resetGameState(preserveLoadedState = false) {
       console.log("[Detail] Resetting game state." + (preserveLoadedState ? " (Preserving loaded indices)" : ""));
        this.isMenuVisible = false;
        this.recoveryMode = RECOVERY_MODE_NONE;
        this.achievedEnding = '';
        this.clearTypingTimeout();
        // Only reset indices if NOT preserving state from a load operation *before* chapter load
        if (!preserveLoadedState) {
            this.currentScene = 0;
            this.currentDialogue = 0;
            this.choicesMade = [];
        }
        // Don't reset this.chapter here, it's set by the loading logic
        // Don't reset gameData.scenes here, it's handled by loadChapterDataInternal
    },

    // Loads chapter based on IDENTIFIER ('BE', 'TE') or INDEX (number)
    loadChapterData(chapterIndexOrIdentifier) {
      console.log(`[Detail] Request load chapter: ${chapterIndexOrIdentifier}`);
      let targetIndex = -1;
      let isSpecialChapter = false;

      // Determine target index and identifier
      if (chapterIndexOrIdentifier === 'BE') {
          this.chapter = 'BE'; targetIndex = 32; isSpecialChapter = true;
      } else if (chapterIndexOrIdentifier === 'TE') {
          this.chapter = 'TE'; targetIndex = 33; isSpecialChapter = true;
      } else if (typeof chapterIndexOrIdentifier === 'number') {
           // If loading a specific chapter index, update the stored chapter value
           this.chapter = chapterIndexOrIdentifier;
           targetIndex = chapterIndexOrIdentifier;
           isSpecialChapter = false; // Loading a normal numbered chapter
      } else {
           console.error(`[Detail] Invalid chapter identifier type: ${chapterIndexOrIdentifier}`);
           prompt.showToast({ message: "错误：无效章节" });
           targetIndex = 0; // Fallback
           this.chapter = 0; // Reset chapter state
      }

      // Reset choices only if starting a new chapter sequence (not loading a save into a chapter)
      // We track if it's a save load via `isDataLoading` for now, refine later if needed
      // if (!isSpecialChapter && this.loadOnInitData?.type !== 'load') {
      //   this.choicesMade = []; // Reset on normal chapter progression
      // }
      // Safer: Reset choices inside loadChapterDataInternal BEFORE loading file

      console.log(`[Detail] Effective load: Chapter='${this.chapter}', Index=${targetIndex}, Special=${isSpecialChapter}`);
      this.loadChapterDataInternal(targetIndex);
    },

    // Loads chapter data specifically by NUMERIC index
    loadChapterDataInternal(chapterIndex) {
         if (typeof chapterIndex !== 'number' || chapterIndex < 0 || chapterIndex >= this.chapterList.length) {
             console.error(`[Detail] Internal error: Invalid chapter index ${chapterIndex}`);
             prompt.showToast({ message: `错误：无法加载章节索引 ${chapterIndex}` });
             if(chapterIndex !== 0) { this.loadChapterDataInternal(0); } // Fallback to 0
             else { router.back(); } // Critical fail on 0
             return;
         }

         const filename = this.chapterList[chapterIndex];
         const uri = `/common/${filename}.txt`;
         console.log(`[Detail] Reading chapter file: ${uri}`);

         // Reset chapter-specific data HERE before loading
         this.gameData.scenes = [];
         this.choicesMade = []; // Clear choices log for ANY new chapter load

         // Reset indices to 0 UNLESS we are loading a save (loadOnInitData handles this case)
         // This logic needs refinement. Let loadGameFromState handle setting non-zero indices.
         // Assume start from 0 unless loadGameFromState overrides AFTER file load.
         // No, we need to know the indices *before* calling loadScene.
         // The state `this.currentScene`, `this.currentDialogue` should be set correctly *before* calling this.

         console.log(`[Detail] Current scene/dialogue indices before file read: ${this.currentScene}/${this.currentDialogue}`);

          file.readText({
              uri: uri,
              success: (data) => {
                  if (data && data.text) {
                      try {
                          this.gameData.scenes = JSON.parse(data.text);
                          console.log(`[Detail] Parsed ${filename}.txt: ${this.gameData.scenes.length} scenes.`);
                          // Now that data is loaded, apply the state (scene/dialogue)
                          // State should already be set if loading a save.
                          this.applyCurrentSceneState();
                      } catch (e) { console.error(`[Detail] Parse JSON fail ${uri}:`, e); prompt.showToast({ message: `章节 ${filename} 文件错误` }); router.back(); }
                  } else { console.error(`[Detail] Empty file: ${uri}`); prompt.showToast({ message: `章节 ${filename} 文件为空` }); router.back(); }
              },
              fail: (data, code) => { console.error(`[Detail] Read file fail ${uri}: ${data}, ${code}`); prompt.showToast({ message: `无法读取章节 ${filename}` }); router.back(); },
              complete: () => { console.log(`[Detail] File read complete for ${uri}`); }
          });
    },

    // Applies the current state (scene/dialogue indices) after chapter data is ready
    applyCurrentSceneState() {
        console.log(`[Detail] Applying scene state: Scene=${this.currentScene}, Dialogue=${this.currentDialogue}`);
        // Validate indices against newly loaded data
        if (this.currentScene < 0 || this.currentScene >= this.gameData.scenes.length) {
            console.error(`[Detail] Invalid scene index ${this.currentScene} after load. Resetting.`);
            this.currentScene = 0;
            this.currentDialogue = 0;
        }
        const scene = this.gameData.scenes[this.currentScene];
         if (scene && scene.dialogues && (this.currentDialogue < 0 || this.currentDialogue >= scene.dialogues.length)) {
             console.warn(`[Detail] Invalid dialogue index ${this.currentDialogue} after load. Resetting.`);
             this.currentDialogue = 0;
         }
        // Load the scene using potentially adjusted indices
        this.loadScene(this.currentScene);
    },

    // --- Scene/Dialogue Progression ---
    loadScene(sceneIndex) {
        console.log(`[Detail] --- Loading Scene Index: ${sceneIndex} ---`);
        this.clearTypingTimeout(); // Stop typing

        if (!this.gameData?.scenes || sceneIndex < 0 || sceneIndex >= this.gameData.scenes.length) {
            console.error(`[Detail] loadScene: Invalid scene index ${sceneIndex} or no scenes data.`);
            this.handleChapterEnd(); // Attempt recovery
            return;
        }

        this.currentScene = sceneIndex; // Update state FIRST
        const scene = this.gameData.scenes[this.currentScene];
        console.log(`[Detail] Scene ${sceneIndex} Data: ${JSON.stringify(scene)}`);

        if (!scene) { /* Should be caught by index check, but safety */ console.error("[Detail] Scene data unexpectedly null."); this.handleChapterEnd(); return; }

        this.currentBackground = scene.background || DEFAULT_BG; // Set background

        // *** Core Logic: Choices or Dialogues? ***
        if (scene.choices && scene.choices.length > 0) {
            console.log(`[Detail] Scene ${sceneIndex} has choices. Preparing choices UI.`);
            this.characterName = ''; this.displayedText = ''; // Clear dialogue display
            this.canProgress = false; // Require choice selection
            // NOTE: showChoicesUI computed property will become true, triggering UI update via 'if'
        } else if (scene.dialogues && scene.dialogues.length > 0) {
            console.log(`[Detail] Scene ${sceneIndex} has dialogues. Loading dialogue ${this.currentDialogue}.`);
             // Validate dialogue index for this specific scene
             if (this.currentDialogue < 0 || this.currentDialogue >= scene.dialogues.length) {
                 console.warn(`[Detail] Dialogue index ${this.currentDialogue} invalid for scene ${sceneIndex}. Resetting to 0.`);
                 this.currentDialogue = 0;
             }
            this.loadDialogue(scene.dialogues[this.currentDialogue]);
        } else {
            // Scene has neither valid choices nor dialogues
            console.log(`[Detail] Scene ${sceneIndex} is empty (no choices/dialogues). Proceeding.`);
            // Trigger end-of-dialogue logic which handles transitions/jumps etc. based on scene properties
            this.handleDialogueEnd();
        }
    },

    loadDialogue(dialogue) {
        if (!dialogue) { console.error("[Detail] loadDialogue: Received null/undefined dialogue."); this.handleDialogueEnd(); return; }
        console.log(`[Detail] Loading dialogue: Character='${dialogue.character}', Text='${(dialogue.text || "").substring(0,20)}...'`);
        if(this.showDialogueUI) { this.scrollToTop(); } // Scroll only if UI is visible
        this.clearTypingTimeout(); // Clear previous timer
        this.characterName = dialogue.character || '';
        this.fullDialogueText = dialogue.text || '';
        this.displayedText = '';
        this.typingIndex = 0;
        this.canProgress = false; // Disable click-through until text finishes
        this.startTypingEffect();
    },

    startTypingEffect() {
        // Stop if menu/overlays are active or choices shown
       if (this.isMenuVisible || this.recoveryMode !== RECOVERY_MODE_NONE || this.achievedEnding || this.showChoicesUI) { this.clearTypingTimeout(); return; } // Added showChoicesUI check
        if (this.typingIndex < this.fullDialogueText.length) {
            this.displayedText += this.fullDialogueText.charAt(this.typingIndex);
            this.typingIndex++;
            this.typingTimeoutId = setTimeout(() => { this.startTypingEffect(); }, this.settings.textSpeed);
        } else {
            this.canProgress = true; this.typingTimeoutId = null; } // Finished
    },

    // --- Player Actions & Game Flow ---
    nextDialogue() {
        console.log(`[Detail] nextDialogue clicked. CanProgress=${this.canProgress}, Menu=${this.isMenuVisible}, Recovery=${this.recoveryMode}, Ending=${!!this.achievedEnding}, Choices=${this.showChoicesUI}`);
        // 1. Block if overlays/choices/ending active
        if (this.isMenuVisible || this.recoveryMode !== RECOVERY_MODE_NONE || this.achievedEnding || this.showChoicesUI) { console.log("[Detail] Progression blocked: Overlay/Choices/Ending."); return; }

        // 2. If typing, skip animation
        if (!this.canProgress && this.typingTimeoutId) {
            console.log("[Detail] Skipping text animation."); this.clearTypingTimeout();
            this.displayedText = this.fullDialogueText; this.canProgress = true; return; // Wait for next click
        }

        // 3. If ready to progress (text finished or skipped)
        if (this.canProgress) {
            console.log("[Detail] Progressing dialogue/scene...");
             const scene = this.gameData?.scenes?.[this.currentScene];
             if (!scene?.dialogues || this.currentDialogue >= scene.dialogues.length - 1) {
                 // If no dialogues OR at the last dialogue line
                 console.log("[Detail] End of dialogues for current scene reached. Handling dialogue end.");
                 this.handleDialogueEnd();
             } else {
                 // Go to next dialogue line within the scene
                 this.currentDialogue++;
                 console.log(`[Detail] Moving to next dialogue line: ${this.currentDialogue}`);
                 this.loadDialogue(scene.dialogues[this.currentDialogue]);
             }
        } else {
             console.log("[Detail] Click ignored: Cannot progress yet.");
        }
    },

     handleDialogueEnd() {
        // This function decides what happens AFTER the last dialogue line of a scene is shown/skipped
        console.log(`[Detail] handleDialogueEnd called for Scene ${this.currentScene}, Dialogue ${this.currentDialogue}`);
        const scene = this.gameData?.scenes?.[this.currentScene];
        // Get the *effective* last dialogue object, even if the scene had none initially
        const lastDialogue = (scene?.dialogues && scene.dialogues.length > 0) ? scene.dialogues[scene.dialogues.length - 1] : null;
        // Use the currently finished dialogue index if valid, fallback to end
        const currentDialogueObj = scene?.dialogues?.[this.currentDialogue];

        // Check conditions based on the properties of the DIALOGUE object just finished, OR scene properties if no dialogues
        const conditionSource = currentDialogueObj || scene; // Check dialogue first, then scene

        if (!conditionSource) { console.error("[Detail] Cannot determine conditions in handleDialogueEnd."); this.handleSceneEnd(); return; } // Safety break

        console.log("[Detail] Checking end conditions on:", conditionSource);

        // Priority: Ending > Branch > Jump > Next Scene
        if (conditionSource.END !== undefined) { console.log("[Detail] Condition: END"); this.triggerEnding(conditionSource.END); }
        else if (conditionSource.branch !== undefined) { console.log("[Detail] Condition: BRANCH"); this.evaluateBranch(conditionSource.branch); }
        else if (conditionSource.toScenes !== undefined) { console.log("[Detail] Condition: JUMP");
            const jumpAmount = parseInt(conditionSource.toScenes, 10);
            if (!isNaN(jumpAmount)) { this.currentDialogue = 0; this.loadScene(this.currentScene + jumpAmount); } // Reset dialogue index for jump
            else { console.error("[Detail] Invalid toScenes:", conditionSource.toScenes); this.handleSceneEnd(); }
        }
        else { console.log("[Detail] Condition: None on dialogue/scene. Moving to standard scene end."); this.handleSceneEnd(); } // Default: move to next scene
    },

    handleSceneEnd() {
        // This function decides what happens AFTER a scene truly ends (no jumps/branches etc.)
        console.log(`[Detail] handleSceneEnd called for Scene ${this.currentScene}`);
        if (!this.gameData?.scenes) { console.error("[Detail] No scenes data in handleSceneEnd."); this.goToHomePage(); return; }

        if (this.currentScene < this.gameData.scenes.length - 1) {
            // Go to next scene in sequence
            console.log("[Detail] Moving to next scene via handleSceneEnd.");
            this.currentDialogue = 0; // Reset dialogue index for next scene
            this.loadScene(this.currentScene + 1);
        } else {
             // Last scene of the chapter
            console.log("[Detail] Last scene reached. Handling chapter end.");
            this.handleChapterEnd();
        }
    },

    handleChapterEnd() {
        console.log(`[Detail] handleChapterEnd for Chapter: ${this.chapter}`);
        this.currentBackground = DEFAULT_BG; this.characterName = ''; this.displayedText = ''; this.canProgress = false;

         let nextChapterIndex = -1;
         if (typeof this.chapter === 'number') { nextChapterIndex = this.chapter + 1; }
         else { console.log(`[Detail] Non-numeric chapter ${this.chapter} ended. Returning home.`); prompt.showToast({ message: "特殊章节结束" }); setTimeout(() => { this.goToHomePage(); }, 1500); return; }

         if (nextChapterIndex >= 0 && nextChapterIndex < this.chapterList.length) {
              console.log(`[Detail] Loading next chapter index: ${nextChapterIndex}`); prompt.showToast({ message: `载入: ${this.chapterList[nextChapterIndex]}`});
              // Reset state *before* loading next chapter
               this.currentScene = 0; this.currentDialogue = 0; this.choicesMade = []; // Reset for new chapter
               setTimeout(() => { this.loadChapterData(nextChapterIndex); }, 1500); // Load next
         } else {
             console.log(`[Detail] No more chapters after ${this.chapter}. Game end.`); prompt.showToast({ message: "游戏流程结束" });
             setTimeout(() => { this.goToHomePage(); }, 1500);
         }
    },

    evaluateBranch(branchData) {
        console.log("[Detail] Evaluating branch:", JSON.stringify(branchData), "Choices:", JSON.stringify(this.choicesMade));
        if (!branchData || !branchData.choices || branchData.toChapter === undefined) { console.error("[Detail] Invalid branch data."); this.handleSceneEnd(); return; }
        const match = JSON.stringify(this.choicesMade) === JSON.stringify(branchData.choices);
        let targetChapter = -1;
        if (match) { targetChapter = branchData.toChapter; console.log("[Detail] Branch condition met."); }
        else if (branchData.elseChapter !== undefined) { targetChapter = branchData.elseChapter; console.log("[Detail] Branch condition NOT met, using elseChapter."); }
        else { console.warn("[Detail] Branch condition failed, no else. Proceeding normally."); this.handleSceneEnd(); return; }

        console.log(`[Detail] Branching to chapter: ${targetChapter}`);
         // Reset state for new chapter sequence
         this.currentScene = 0; this.currentDialogue = 0; this.choicesMade = [];
        this.loadChapterData(targetChapter); // Load the target chapter/identifier
    },

    selectChoice(choiceIndex) {
         const scene = this.gameData?.scenes?.[this.currentScene];
         if (!scene?.choices?.[choiceIndex]) { console.error("[Detail] Invalid choice index selected:", choiceIndex); return; }
         const choice = scene.choices[choiceIndex];
         console.log(`[Detail] Choice ${choiceIndex} selected: '${choice.text}', Offset=${choice.nextScene}`);
         this.choicesMade.push(choiceIndex);

         const offset = choice.nextScene;
         if (typeof offset !== 'number') { console.error("[Detail] Invalid choice offset:", offset); this.handleSceneEnd /* Attempt recovery */; return; }

         // Reset dialogue index before loading next scene from choice
         this.currentDialogue = 0;
         this.loadScene(this.currentScene + offset);
    },

    // --- Menu & Overlays ---
    handleSwipeBack(event) {
      // Only allow swipe if game is in a stable state
      if (event.direction === 'right' && !this.isMenuVisible && this.recoveryMode === RECOVERY_MODE_NONE && !this.achievedEnding && !this.showChoicesUI && this.canProgress && !this.isDataLoading ) {
        console.log("[Detail] Swipe right: Opening menu.");
        this.isMenuVisible = true;
        this.clearTypingTimeout(); this.canProgress = false;
      } else { console.log("[Detail] Swipe right ignored."); }
    },
    closeMenu() {
      console.log("[Detail] Closing menu.");
      this.isMenuVisible = false;
      // Re-enable progress only if not in choices/ending state
      this.canProgress = !this.showChoicesUI && !this.achievedEnding && !this.isDataLoading;
    },
     goToHomePage() {
      console.log("[Detail] Returning to Home.");
      router.replace({ uri: "/pages/index" });
    },
    toRecoveryPage(mode) { // mode = 1 (Save) or 2 (Load)
        console.log(`[Detail] Opening Recovery Overlay: Mode=${mode}`);
        if (mode === RECOVERY_MODE_LOAD && (!this.recoveryData || this.recoveryData.length === 0)) {
            prompt.showToast({ message: "没有存档可供读取" }); return;
        }
        this.recoveryMode = mode;
        this.isMenuVisible = false; // Close menu when opening save/load
    },
    closeRecoveryOverlay() {
        console.log("[Detail] Closing Recovery Overlay.");
        this.recoveryMode = RECOVERY_MODE_NONE;
        // Decide where to return - back to menu is often expected
        this.isMenuVisible = true;
        this.canProgress = false; // Keep game paused
    },

    // --- Save / Load ---
     saveRecoveryData(indexOrNew) {
        console.log(`[Detail] saveRecoveryData: Target=${indexOrNew}`);
        const currentState = { chapter: this.chapter, currentScene: this.currentScene, currentDialogue: this.currentDialogue, choicesMade: [...this.choicesMade], timestamp: new Date().toISOString() };
        if (indexOrNew === 'new') {
            if (this.recoveryData.length >= 10) { prompt.showToast({ message: '存档已满' }); return; }
            this.recoveryData.push(currentState); prompt.showToast({ message: '保存成功' });
        } else if (typeof indexOrNew === 'number' && indexOrNew >= 0 && indexOrNew < this.recoveryData.length) {
            this.recoveryData[indexOrNew] = currentState; prompt.showToast({ message: '覆盖成功' });
        } else { console.error("[Detail] Invalid save index:", indexOrNew); prompt.showToast({ message: '保存失败' }); return; }
        this.persistRecoveryData();
        this.closeRecoveryOverlay(); // Return to menu
      },

      deleteRecoveryData(index) {
          console.log(`[Detail] Request delete save index: ${index}`);
          // Add confirmation dialog
          prompt.showDialog({ title: '确认删除', message: `确定要删除存档 ${index + 1} 吗？`, buttons: [{ text: '取消'}, { text: '删除', color: '#DD2C00' }], // Use a known red
              success: (data) => {
                  if (data.index === 1) { // Delete confirmed
                      if (index >= 0 && index < this.recoveryData.length) {
                          console.log("[Detail] Deleting save slot confirmed."); this.recoveryData.splice(index, 1); this.persistRecoveryData(); prompt.showToast({ message: '删除成功' });
                      } else { console.error("[Detail] Invalid index for deletion:", index); prompt.showToast({ message: '删除失败' }); }
                  } else { prompt.showToast({ message: '已取消' }); }
              },
              fail: (err) => { console.error("[Detail] Delete Dialog fail:", err); prompt.showToast({ message: '操作失败' }); },
              complete: () => {}
          })
      },

      loadRecoveryData(index) {
         console.log(`[Detail] Request load save index: ${index}`);
        if (index >= 0 && index < this.recoveryData.length) {
          const saveData = this.recoveryData[index];
          prompt.showToast({ message: `读取存档 ${index + 1}...` });
          this.recoveryMode = RECOVERY_MODE_NONE; // Close overlay immediately
          this.isMenuVisible = false; // Ensure menu closed
          this.loadGameFromState(saveData); // Initiate load process
        } else { console.error("[Detail] Invalid load index:", index); prompt.showToast({ message: '无效存档' }); }
      },

    loadGameFromState(stateData) {
        if (!stateData) { console.error("[Detail] loadGameFromState: stateData is null!"); return; }
        console.log("[Detail] Loading game state from:", JSON.stringify(stateData));
        this.isDataLoading = true; // Enter loading state
        this.clearTypingTimeout();
        this.resetGameState(true); // Reset state BUT preserve indices

        // *** Crucially, restore state *before* calling loadChapterData ***
        this.chapter = stateData.chapter; // Can be 'BE', 'TE', or number
        this.currentScene = stateData.currentScene;
        this.currentDialogue = stateData.currentDialogue;
        this.choicesMade = stateData.choicesMade ? [...stateData.choicesMade] : [];

        console.log(`[Detail] State restored: Chapter=${this.chapter}, Scene=${this.currentScene}, Dialogue=${this.currentDialogue}, Choices=${JSON.stringify(this.choicesMade)}`);

        // Now load the chapter data. This will use the restored indices in applyCurrentSceneState.
        this.loadChapterData(this.chapter); // Load based on restored chapter identifier/index

         // Unlock after a delay to allow loading/rendering
         setTimeout(() => {
             this.isDataLoading = false;
             this.canProgress = !this.showChoicesUI && !this.achievedEnding && !this.isMenuVisible;
             console.log(`[Detail] Load complete. Can progress = ${this.canProgress}`);
         }, 200); // Slightly longer delay for safety
    },

    persistRecoveryData() {
        console.log("[Detail] Persisting recovery data...");
        try {
            const value = JSON.stringify(this.recoveryData);
             storage.set({ key: STORAGE_KEYS.RECOVERY_DATA, value: value,
                 success: () => { console.log("[Detail] Recovery data saved."); },
                 fail: (d, c) => { console.error(`[Detail] Save recovery fail: ${d}, ${c}`); prompt.showToast({ message: `存档列表保存失败` }); },
                 complete: () => {}
             });
        } catch (e) { console.error("[Detail] Stringify recovery error:", e); prompt.showToast({ message: '存档数据异常' }); }
    },

    // --- Skip ---
     skipScene() {
         console.log("[Detail] Action: Skip Scene");
         if (this.isDataLoading || this.showChoicesUI || this.achievedEnding) { prompt.showToast({ message: '当前无法跳过' }); this.closeMenu(); return; }
         const scene = this.gameData?.scenes?.[this.currentScene];
         const lastDialogue = scene?.dialogues?.slice(-1)?.[0]; // Get last dialogue element if exists
         const isSkippable = !( scene?.choices || lastDialogue?.END || lastDialogue?.branch || lastDialogue?.toScenes );
         const isLastScene = this.currentScene >= (this.gameData?.scenes?.length || 0) - 1;
         if (isSkippable && !isLastScene) { prompt.showToast({ message: "跳过场景" }); this.closeMenu(); this.clearTypingTimeout(); this.currentDialogue = 0; this.loadScene(this.currentScene + 1); }
         else { prompt.showToast({ message: '无法跳过此场景' }); this.closeMenu(); }
      },
     skipCurrentChapter() {
         console.log("[Detail] Action: Skip Chapter");
         if (this.isDataLoading || this.achievedEnding) { prompt.showToast({ message: '当前无法跳过' }); this.closeMenu(); return; }
         // Simplified skip check based on your original logic
         const unskippableChapters = [2, 19, 25, 26]; const endingChapters = ['TE', 'BE'];
         const lastChapterIndex = 31; // Example
         const isUnskippable = unskippableChapters.includes(this.chapter) || endingChapters.includes(this.chapter) || (typeof this.chapter === 'number' && this.chapter >= lastChapterIndex);

         if (isUnskippable) { prompt.showToast({ message: '此章节无法跳过' }); this.closeMenu(); }
         else if (typeof this.chapter === 'number') { prompt.showToast({ message: "跳过章节..." }); this.closeMenu(); this.clearTypingTimeout(); this.handleChapterEnd(); }
         else { console.warn("[Detail] Cannot skip non-numeric/non-ending chapter:", this.chapter); prompt.showToast({ message: '无法跳过' }); this.closeMenu(); }
     },

    // --- Ending ---
     triggerEnding(endingName) { /* ... as before ... */
         if (this.achievedEnding) return; console.log(`[Detail] Trigger Ending: ${endingName}`);
         this.achievedEnding = endingName; this.updateFinStatus(endingName);
         this.canProgress = false; this.clearTypingTimeout(); this.isMenuVisible = false; this.recoveryMode = RECOVERY_MODE_NONE;
         prompt.showToast({message: `达成结局：${endingName}`})
     },
     updateFinStatus(endingName) { /* ... as before, ensure complete callback ... */
         storage.get({ key: STORAGE_KEYS.FIN_STATUS,
             success: (data) => { /* ... parse logic ... */
                 let finStatus = { HE: false, BE: false, ...(data ? JSON.parse(data) : {}) };
                 if (endingName === ENDING_TYPES.HE) finStatus.HE = true; else if (endingName === ENDING_TYPES.BE) finStatus.BE = true;
                 storage.set({ key: STORAGE_KEYS.FIN_STATUS, value: JSON.stringify(finStatus),
                     success: () => { console.log("[Detail] Fin status saved:", finStatus); },
                     fail: (d,c)=>{ console.error(`[Detail] Save fin fail: ${d}, ${c}`); },
                     complete: () => {} }); },
             fail: (d, c) => { console.error(`[Detail] Get fin fail: ${d}, ${c}`); },
             complete: () => {}
         });
     },

    // --- Utils ---
    clearTypingTimeout() { /* ... as before ... */
       if (this.typingTimeoutId) { clearTimeout(this.typingTimeoutId); this.typingTimeoutId = null; }
    },
    scrollToTop() { /* ... as before ... */
       try { this.$element('dialogueScroll')?.scrollTo({ y: 0, smooth: false }); } catch (e) { console.error("[Detail] Scroll fail:", e); }
    },
  }
</script>
