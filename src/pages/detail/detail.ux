<template>
  <!-- Root container -->
  <div class="page-container" @swipe="handleSwipeBack">

    <!-- Dialogue Layer -->
    <div class="dialogue-layer" @click="nextDialogue">
      <image class="dialogue-background" src="/common/images/{{ currentBackground }}"></image>
      <image class="scene-image" src="/common/images/{{ gameData.scenes[currentScene].Img }}" style="top:{{gameData.scenes[currentScene].ImgTop}}px; left:{{gameData.scenes[currentScene].ImgLeft}}px;" if="{{ showSceneImage }}"></image>

      <text class="dialogue-character" if="{{ showDialogueUI }}">{{ characterName }}</text>

      <div class="dialogue-ui" if="{{ showDialogueUI }}" @longpress="openHistoryPage">
        <image class="dialogue-text-bg" src="/common/images/text_bg.png"></image>
        <scroll scroll-y="true" bounces="true" class="dialogue-scroll" id="dialogueScroll">
          <text class="dialogue-text" style="font-size: {{ settings.textSize }}px;">{{ displayedText }}</text>
        </scroll>
      </div>
    </div>

    <!-- Choices Overlay -->
    <div class="overlay choices-overlay" if="{{ showChoicesUI }}">
        <text
            class="choice-button"
            for="{{ (index, choice) in gameData.scenes[currentScene].choices }}"
            style="top: {{ 100 + index * 85 }}px; left: 43px;"
            @click="selectChoice(index)">
            {{ choice.text }}
        </text>
    </div>

    <!-- Menu Overlay -->
    <div class="overlay menu-overlay" if="{{ isMenuVisible }}">
      <text class="menu-button" @click="toRecoveryPage(1)">保存</text>
      <text class="menu-button" @click="toRecoveryPage(2)">加载</text>
      <text class="menu-button quick-save-button" @click="quickSave()">快速存档</text>
      <text class="menu-button" @click="quickLoad()">快速读档</text>
      <text class="menu-button" @click="skipScene()">跳过场景</text>
      <text class="menu-button" @click="skipCurrentChapter()">跳过章节</text>
      <text class="menu-button" @click="closeMenu()">返回</text>
      <text class="menu-button" @click="goToHomePage()">返回主页</text>
    </div>

    <!-- Save Overlay -->
    <div class="overlay save-load-overlay" if="{{ recoveryMode === 1 }}">
      <scroll scroll-y="true" bounces="true" class="save-load-scroll">
        <text class="save-load-title">长按删除，点击覆盖 (第1个为快存)</text>
        <text class="save-load-slot {{ $idx === 0 ? 'quick-save-slot' : '' }}" for="{{ (index, slot) in recoveryData }}" @click="saveRecoveryData(index)" @longpress="deleteRecoveryData(index)">存档 {{ index + 1 }}</text>
        <text class="save-load-slot save-load-new" @click="saveRecoveryData('new')">+</text>
      </scroll>
       <text class="save-load-close-button" @click="closeRecoveryOverlay">关闭</text>
    </div>

    <!-- Load Overlay -->
    <div class="overlay save-load-overlay" if="{{ recoveryMode === 2 }}">
      <scroll scroll-y="true" bounces="true" class="save-load-scroll">
        <text class="save-load-title">点击读取存档 (第1个为快存)</text>
        <text class="save-load-slot {{ $idx === 0 ? 'quick-save-slot' : '' }}" for="{{ (index, slot) in recoveryData }}" @click="loadRecoveryData(index)">存档 {{ index + 1 }}</text>
         <text class="save-load-empty" if="{{!recoveryData || recoveryData.length === 0}}">还没有存档哦</text>
      </scroll>
       <text class="save-load-close-button" @click="closeRecoveryOverlay">关闭</text>
    </div>

    <!-- End Game Overlay -->
    <div class="overlay end-game-overlay" if="{{ achievedEnding }}">
      <text class="end-game-title">达成结局：</text>
      <text class="end-game-name">{{ achievedEnding }}</text>
      <text class="end-game-back" @click="goToHomePage">返回主页</text>
    </div>
  </div>
</template>

<style>
  /* === Base & Dialogue Styles === */
  .page-container { width: 336px; height: 480px; position: relative; background-color: #000000; overflow: hidden; }
  .dialogue-layer { width: 100%; height: 100%; position: relative; background-color: #000000; }
  .dialogue-background { width: 100%; height: 100%; object-fit: cover; }
  .scene-image { position: absolute; }
  .dialogue-ui { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; }
  .dialogue-text-bg { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; }
  .dialogue-character {
    position: absolute;
    bottom: 175px;
    left: 8px;
    font-size: 28px;
    color: #ffffff;
    font-weight: bold;
  }
  .dialogue-scroll { position: absolute; bottom: 10px; left: 8px; right: 8px; height: 145px; overflow: hidden; flex-wrap: wrap; }
  .dialogue-text { color: #ffffff; font-weight: bold; width: 100%; text-align: left; }

  /* === Overlay Base === */
  .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.5); flex-direction: column; }

  /* === Choices Overlay & Button === */
  .choices-overlay {
    background-color: transparent;
  }
  .choice-button {
    position: absolute;
    width: 250px;
    height: 61px;
    left: 43px;
    background-color: rgba(80, 192, 231, 0.85);
    color: #ffffff;
    font-size: 22px;
    font-weight: bold;
    text-align: center;
    padding: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
  }

  /* === Menu Overlay & Buttons === */
  .menu-overlay { background-color: rgba(255, 255, 255, 0.95); padding-top: 15px; padding-bottom: 15px; }
  .menu-button {
    width: 230px;
    height: 50px;
    background-color: rgba(80, 192, 231, 0.8);
    color: #ffffff;
    font-size: 22px;
    font-weight: bold;
    text-align: center;
    margin-bottom: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    flex-shrink: 0;
  }
  .quick-save-button {
      background-color: rgba(100, 210, 100, 0.8);
  }

  /* === Save/Load Overlay === */
  .save-load-overlay { background-color: rgba(255, 255, 255, 0.95); justify-content: flex-start; padding: 15px; }
  .save-load-scroll { width: 100%; height: 82%; display: flex; flex-direction: column; align-items: center; margin-bottom: 5px; }
  .save-load-title { font-size: 18px; color: #333333; margin-bottom: 15px; font-weight: bold; flex-shrink: 0; text-align: center; }
  .save-load-slot { width: 95%; max-width: 280px; height: 50px; background-color: rgba(80, 192, 231, 0.7); color: #ffffff; font-size: 20px; font-weight: bold; text-align: center; margin-bottom: 12px; display: flex; justify-content: center; align-items: center; border-radius: 8px; flex-shrink: 0; }
  .quick-save-slot { border: 2px solid #ffd700; }
  .save-load-new { font-size: 30px; background-color: rgba(100, 210, 100, 0.8); }
  .save-load-empty { margin-top: 20px; font-size: 18px; color: #888888; flex-shrink: 0; }
  .save-load-close-button { font-size: 18px; color: #007aff; padding: 8px; margin-top: auto; flex-shrink: 0; }

  /* === End Game Overlay === */
  .end-game-overlay { background-color: rgba(255, 255, 255, 0.95); }
  .end-game-title { font-size: 28px; color: #333333; margin-bottom: 10px; }
  .end-game-name { font-size: 32px; color: #000000; font-weight: bold; margin-bottom: 40px; text-align: center; }
  .end-game-back { font-size: 24px; color: #007aff; padding: 10px; }
</style>

<script>
  import router from '@system.router';
  import storage from '@system.storage';
  import prompt from '@system.prompt';
  import file from '@system.file';

  const STORAGE_KEYS = { RECOVERY_DATA: 'recoveryData', SETTINGS: 'settings', FIN_STATUS: 'fin' };
  const DEFAULT_BG = 'bg.png';
  const ENDING_TYPES = { HE: "Happy Ending", BE: "Bad Ending" };
  const RECOVERY_MODE_NONE = 0; const RECOVERY_MODE_SAVE = 1; const RECOVERY_MODE_LOAD = 2;
  const QUICK_SAVE_SLOT_INDEX = 0;
  const DEFAULT_SETTINGS_DETAIL = { textSpeed: 40, textSize: 22 };

  export default {
    props: ['load', 'loadFromHistory'],
    private: {
      gameData: { scenes: [], },
      chapter: 0,
      currentScene: 0,
      currentDialogue: 0,
      choicesMade: [],
      chapterList: ['b999','b101','b102','b103','b111','b112','b113','b114','b121','b122','b123','b124','b200','b201','b202','b203','b204','b205','b206','b207','b301','b302','b303','b304','b401','b402','b403','b404','b405','b406','b407','b501','b601','b701'],
      currentBackground: DEFAULT_BG,
      characterName: '',
      displayedText: '',
      isMenuVisible: false,
      recoveryMode: RECOVERY_MODE_NONE,
      achievedEnding: '',
      fullDialogueText: '',
      typingIndex: 0,
      typingTimeoutId: null,
      canProgress: true,
      settings: { ...DEFAULT_SETTINGS_DETAIL },
      recoveryData: [],
      isDataLoading: true,
      fullDialogueLog: [],
    },
    computed: {
        showSceneImage() { 
          // 确保数据加载完成且场景数据有效时才显示场景图片
          return !this.isDataLoading && this.gameData.scenes && this.gameData.scenes.length > this.currentScene && this.gameData.scenes[this.currentScene]?.Img !== undefined; 
        },
        showDialogueUI() { 
          // 修复：确保在数据加载完成后才显示对话UI
          if (this.isDataLoading || !this.gameData.scenes || this.gameData.scenes.length <= this.currentScene) return false; 
          const scene = this.gameData.scenes[this.currentScene]; 
          // 只要有对话内容就显示UI，不依赖背景图
          return scene && scene.dialogues && scene.dialogues.length > 0 && !scene?.choices; 
        },
        showChoicesUI() { 
          if (this.isDataLoading || !this.gameData.scenes || this.gameData.scenes.length <= this.currentScene) return false; 
          const scene = this.gameData.scenes[this.currentScene]; 
          const hasChoices = !!scene?.choices && scene.choices.length > 0; 
          return hasChoices; 
        }
    },

    onInit() {
        this.isDataLoading = true;
        // 增加日志，清晰打印接收到的 prop
        console.log(`[Detail] ONINIT START. Prop 'load' received: ${JSON.stringify(this.load)}`);
        console.log(`[Detail] ONINIT START. Prop 'loadFromHistory' received: ${JSON.stringify(this.loadFromHistory)}`);

        this.loadSettingsAndRecovery().then(() => {
            console.log("[Detail] ONINIT: Settings and Recovery loaded successfully.");
            if (this.loadFromHistory && typeof this.loadFromHistory === 'object') {
                console.log("[Detail] ONINIT: Processing 'loadFromHistory'. Data:", JSON.stringify(this.loadFromHistory));
                const { chapter, scene, dialogue, choicesMade } = this.loadFromHistory;
                this.resetGameState(true);
                this.chapter = chapter;
                this.currentScene = scene;
                this.currentDialogue = dialogue;
                this.choicesMade = Array.isArray(choicesMade) ? [...choicesMade] : [];
                this.fullDialogueLog = [];
                console.log(`[Detail] ONINIT: State set from history - Ch=${this.chapter}, S=${this.currentScene}, D=${this.currentDialogue}, Choices=${JSON.stringify(this.choicesMade)}`);
                this.loadChapterData(this.chapter);
            } else if (this.load && typeof this.load === 'object') {
                console.log("[Detail] ONINIT: Processing 'load' param (e.g., from index page). Data:", JSON.stringify(this.load));
                this.startGameFromInitData(this.load);
            } else {
                console.log("[Detail] ONINIT: No specific load params, starting new game (chapter 0).");
                this.startGameFromInitData({ type: 'chapter', index: 0 });
            }
        }).catch(err => {
            console.error("[Detail] ONINIT: Critical error during loadSettingsAndRecovery. Error:", err);
            this.isDataLoading = false;
            prompt.showToast({message: "初始化游戏失败，请重试"});
            router.replace({uri: "/pages/index"});
        });
    },
    onShow() {
      console.log("[Detail] onShow triggered. Reloading settings.");
      storage.get({
        key: STORAGE_KEYS.SETTINGS,
        success: (d) => {
          let s = {};
          if (d) {
            try { s = JSON.parse(d); } catch (e) { console.error("[Detail] Error parsing settings in onShow:", e); }
          }
          this.settings = { ...DEFAULT_SETTINGS_DETAIL, ...s };
          console.log("[Detail] Settings reloaded in onShow:", JSON.stringify(this.settings));
        },
        fail: (d, c) => {
          console.warn(`[Detail] Load settings in onShow fail: ${d}, ${c}`);
        }
      });
    },
    onDestroy() { this.clearTypingTimeout(); },

    loadSettingsAndRecovery() {
        console.log("[Detail] loadSettingsAndRecovery called.");
        return new Promise((resolve, reject) => {
            let settingsLoaded = false;
            let recoveryLoaded = false;
            const checkAndResolve = () => {
                if (settingsLoaded && recoveryLoaded) {
                    console.log("[Detail] loadSettingsAndRecovery: Both settings and recovery loaded.");
                    resolve();
                }
            };
            const handleError = (type, errorDetails) => {
                console.error(`[Detail] loadSettingsAndRecovery: Error loading ${type}. Details:`, errorDetails);
                // 即使某一项失败，也标记为完成，避免Promise卡住
                if (type === 'settings') settingsLoaded = true;
                if (type === 'recovery') recoveryLoaded = true;
                checkAndResolve(); // 尝试继续
            };

            storage.get({ key: STORAGE_KEYS.SETTINGS,
                success: (d) => {
                    let s = {};
                    if (d) { try { s = JSON.parse(d); } catch (e) {console.error("[Detail] Parse settings in LSaR failed", e)} }
                    this.settings = { ...DEFAULT_SETTINGS_DETAIL, ...s };
                    console.log("[Detail] LSaR: Settings loaded:", JSON.stringify(this.settings));
                },
                fail: (d,c) => handleError('settings', {d,c}),
                complete: () => { settingsLoaded = true; checkAndResolve(); }
            });
            storage.get({ key: STORAGE_KEYS.RECOVERY_DATA,
                success: (d) => {
                    console.log("[Detail] LSaR: Recovery data raw from storage:", d ? d.substring(0, 100) + "..." : "null");
                    if (d) { try { this.recoveryData = JSON.parse(d); } catch (e) { this.recoveryData = []; console.error("[Detail] LSaR: Failed to parse recoveryData", e); } }
                    else { this.recoveryData = []; }
                    console.log(`[Detail] LSaR: Recovery loaded, count: ${this.recoveryData.length}.`);
                },
                fail: (d,c) => handleError('recovery', {d,c}),
                complete: () => { recoveryLoaded = true; checkAndResolve(); }
            });
        });
    },

    startGameFromInitData(loadDataParam) {
        console.log("[Detail] startGameFromInitData called with param:", JSON.stringify(loadDataParam));
        if (!loadDataParam) {
             console.warn("[Detail] SGFI: loadDataParam is null. Navigating to index.");
             router.replace({ uri: "/pages/index" });
             return;
        }
        // 只有当不是从历史记录加载时，才执行 resetGameState
        if (!this.loadFromHistory) {
            this.resetGameState();
        }

        const { type, index } = loadDataParam;

        if (type === 'load' && index !== undefined) {
            console.log(`[Detail] SGFI: Attempting load. Index: ${index}. RecoveryData available: ${!!this.recovery.recoveryData && this.recoveryData[index] ? JSON.stringify(this.recoveryData[index]) : 'INVALID/MISSING'}`);
            if (this.recoveryData && this.recoveryData[index]) {
                this.loadGameFromState(this.recoveryData[index]);
            } else {
                console.warn("[Detail] SGFI: Invalid recovery data or index. Starting new game.");
                prompt.showToast({ message: "存档数据无效，开始新游戏" });
                this.chapter = 0;
                this.loadChapterData(0);
            }
        } else if (type === 'TE') {
            console.log("[Detail] SGFI: Loading True Ending (chapter index 33).");
            this.chapter = 'TE'; 
            this.loadChapterData(33);
        } else if (type === 'BE') {
            console.log("[Detail] SGFI: Loading Bad Ending (chapter index 32).");
            this.chapter = 'BE'; 
            this.loadChapterData(32);
        } else if (type === 'chapter') {
            const chapterIndex = index !== undefined ? index : 0;
            console.log(`[Detail] SGFI: Loading chapter by index: ${chapterIndex}`);
            // 根据索引判断是否为特殊结局
            if (chapterIndex === 33) {
                this.chapter = 'TE';  // True End
            } else if (chapterIndex === 32) {
                this.chapter = 'BE';  // Bad End  
            } else {
                this.chapter = chapterIndex;
            }
            this.loadChapterData(chapterIndex);
        } else {
            if (!this.loadFromHistory) {
                console.warn("[Detail] SGFI: Unknown load type and not from history. Starting new game from chapter 0.", JSON.stringify(loadDataParam));
                this.chapter = 0;
                this.loadChapterData(0);
            } else {
                console.log("[Detail] SGFI: Load type unknown, but was loading from history, state should be set by onInit.");
            }
        }
    },

    resetGameState(preserveIndices = false) {
        console.log("[Detail] Resetting game state. preserveIndices:", preserveIndices);
        this.isMenuVisible = false;
        this.recoveryMode = RECOVERY_MODE_NONE;
        this.achievedEnding = '';
        this.clearTypingTimeout();
        if (!preserveIndices) {
            console.log("[Detail] Resetting indices (scene, dialogue, choices, log).");
            this.currentScene = 0;
            this.currentDialogue = 0;
            this.choicesMade = [];
            this.fullDialogueLog = [];
        } else {
            console.log("[Detail] Preserving indices during reset.");
        }
    },

     loadChapterData(chapterId) {
         console.log(`[Detail] loadChapterData: Request to load chapter with ID: '${chapterId}'`);
         let chapterIndexToLoad = -1;
         let isSpecialChapter = false;

         if (chapterId === 'BE') {
             this.chapter = 'BE';
             chapterIndexToLoad = 32; // BE 对应 chapterList[32] 即 b601.txt
             isSpecialChapter = true;
         } else if (chapterId === 'TE') {
             this.chapter = 'TE';
             chapterIndexToLoad = 33; // TE 对应 chapterList[33] 即 b701.txt
             isSpecialChapter = true;
         } else if (typeof chapterId === 'number') {
             this.chapter = chapterId;
             chapterIndexToLoad = chapterId;
         } else {
             console.error(`[Detail] loadChapterData: Invalid chapter ID type: ${chapterId}, type: ${typeof chapterId}. Defaulting to chapter 0.`);
             this.chapter = 0;
             chapterIndexToLoad = 0;
         }
         console.log(`[Detail] loadChapterData: Effective chapter context set to '${this.chapter}', Index for chapterList: ${chapterIndexToLoad}, IsSpecial: ${isSpecialChapter}`);

         // 只有在不是从历史记录恢复到当前章节的某个对话时，才清空历史对话和选项
         let fromHistoryToThisChapter = this.loadFromHistory && this.loadFromHistory.chapter === this.chapter;
         let fromSave = this.load && this.load.type === 'load';

         if (!fromHistoryToThisChapter) {
            this.fullDialogueLog = []; // 清空对话记录为新章节做准备
            console.log("[Detail] loadChapterData: Cleared fullDialogueLog for new chapter/load.");
         }

         this.loadChapterDataInternal(chapterIndexToLoad);
     },

     loadChapterDataInternal(indexInChapterList) {
         console.log(`[Detail] loadChapterDataInternal: Loading chapter by list index: ${indexInChapterList}. Current state before read: S=${this.currentScene}, D=${this.currentDialogue}`);
         if (typeof indexInChapterList !== 'number' || indexInChapterList < 0 || indexInChapterList >= this.chapterList.length) {
             console.error(`[Detail] LCDI: Internal invalid index ${indexInChapterList} for chapterList. Max index: ${this.chapterList.length - 1}`);
             if(indexInChapterList !== 0) {
                 console.warn("[Detail] LCDI: Attempting to load chapter 0 as fallback.");
                 this.chapter = 0;
                 this.loadChapterDataInternal(0);
             } else {
                 prompt.showToast({message: "章节数据错误"});
                 router.back();
                 this.isDataLoading = false;
             }
             return;
         }
         const filename = this.chapterList[indexInChapterList];
         const uri = `/common/content/${filename}.txt`;
         console.log(`[Detail] LCDI: Reading chapter file: ${uri}.`);
         this.gameData.scenes = [];

         file.readText({ uri: uri,
             success: (d) => {
                 if (d && d.text) {
                     try {
                         this.gameData.scenes = JSON.parse(d.text);
                         console.log(`[Detail] LCDI Success: Parsed ${filename}: ${this.gameData.scenes.length} scenes. Current state before applyCurrentSceneState: Chapter=${this.chapter}, Scene=${this.currentScene}, Dialogue=${this.currentDialogue}`);
                         this.applyCurrentSceneState();
                     } catch (e) {
                         console.error(`[Detail] LCDI: Parse fail ${uri}:`, e);
                         prompt.showToast({message: "解析章节失败"});
                         router.back();
                     }
                 } else {
                     console.error(`[Detail] LCDI: Empty file: ${uri}`);
                     prompt.showToast({message: "章节文件为空"});
                     router.back();
                 }
                 this.isDataLoading = false;
             },
             fail: (d, c) => {
                 console.error(`[Detail] LCDI: Read fail ${uri}: ${d}, ${c}`);
                 prompt.showToast({message: "读取章节失败"});
                 router.back();
                 this.isDataLoading = false;
             },
         });
     },

    applyCurrentSceneState() {
        console.log(`[Detail] ACSS: Applying scene state. Using this.chapter=${this.chapter}, this.currentScene=${this.currentScene}, this.currentDialogue=${this.currentDialogue}`);
        if (!this.gameData || !this.gameData.scenes || this.gameData.scenes.length === 0) {
            console.error("[Detail] ACSS: No scene data loaded for current chapter. Cannot apply state.");
            return;
        }
        if (this.currentScene < 0 || this.currentScene >= this.gameData.scenes.length) {
            console.error(`[Detail] ACSS: Invalid Scene index ${this.currentScene} for ${this.gameData.scenes.length} scenes in chapter ${this.chapter}. Resetting to 0.`);
            this.currentScene = 0;
            this.currentDialogue = 0;
        }
        const scene = this.gameData.scenes[this.currentScene];
        if (scene && scene.dialogues && (this.currentDialogue < 0 || this.currentDialogue >= scene.dialogues.length)) {
            console.warn(`[Detail] ACSS: Invalid Dialogue index ${this.currentDialogue} for scene ${this.currentScene} in chapter ${this.chapter}. Resetting to 0.`);
            this.currentDialogue = 0;
        }

        // 确保 choicesMade 在进入新章节时是清空的
        let fromHistoryToThisChapterPoint = this.loadFromHistory && this.loadFromHistory.chapter === this.chapter && this.loadFromHistory.scene === this.currentScene && this.loadFromHistory.dialogue === this.currentDialogue;
        let fromSave = this.load && this.load.type === 'load'; // 标记是否从存档加载

        if (!fromHistoryToThisChapterPoint && !fromSave && this.currentScene === 0 && this.currentDialogue === 0) {
            console.log("[Detail] ACSS: Entering new chapter or start of chapter (not from history jump to point, not from save), resetting choicesMade.");
            this.choicesMade = [];
        } else if (fromHistoryToThisChapterPoint) {
             console.log("[Detail] ACSS: Restored choicesMade from history prop:", JSON.stringify(this.choicesMade));
        } else if (fromSave) {
            console.log("[Detail] ACSS: choicesMade restored from save data:", JSON.stringify(this.choicesMade));
        }

        this.loadScene(this.currentScene);
    },

    // 修复：添加缺失的方法
    loadScene(sceneIndex) {
      // 暂时保留原始逻辑，确保场景能正常加载
      console.log(`[Detail] Loading scene ${sceneIndex}`);
      // 这里应该有场景加载的具体实现，由于原始代码不完整，
      // 暂时添加基本的场景数据设置
      if (this.gameData.scenes && this.gameData.scenes[sceneIndex]) {
        const scene = this.gameData.scenes[sceneIndex];
        // 设置场景相关的状态
        this.currentBackground = scene.background || DEFAULT_BG;
        // 加载对话或选项
        if (scene.dialogues && scene.dialogues.length > 0) {
          this.loadDialogue();
        }
      }
    },

    loadDialogue() {
      // 基本的对话加载逻辑
      const scene = this.gameData.scenes[this.currentScene];
      if (!scene || !scene.dialogues || this.currentDialogue >= scene.dialogues.length) {
        console.warn("[Detail] No more dialogues in current scene");
        return;
      }
      
      const dialogue = scene.dialogues[this.currentDialogue];
      this.characterName = dialogue.character || '';
      this.fullDialogueText = dialogue.text || '';
      this.displayedText = '';
      this.typingIndex = 0;
      this.startTypingAnimation();
    },

    startTypingAnimation() {
      // 简化的打字动画效果
      this.clearTypingTimeout();
      this.typeNextCharacter();
    },

    typeNextCharacter() {
      if (this.typingIndex < this.fullDialogueText.length) {
        this.displayedText += this.fullDialogueText.charAt(this.typingIndex);
        this.typingIndex++;
        this.typingTimeoutId = setTimeout(() => {
          this.typeNextCharacter();
        }, this.settings.textSpeed || 40);
      }
    },

    clearTypingTimeout() {
      if (this.typingTimeoutId) {
        clearTimeout(this.typingTimeoutId);
        this.typingTimeoutId = null;
      }
    },

    nextDialogue() {
      // 点击继续对话的逻辑
      if (this.typingIndex < this.fullDialogueText.length) {
        // 如果还在打字，直接显示完整文本
        this.displayedText = this.fullDialogueText;
        this.typingIndex = this.fullDialogueText.length;
        this.clearTypingTimeout();
      } else {
        // 进入下一句对话
        this.currentDialogue++;
        this.loadDialogue();
      }
    },

    handleSwipeBack(e) {
      // 右滑打开菜单
      if (e.direction === 'right') {
        this.isMenuVisible = true;
      }
    },

    closeMenu() {
      this.isMenuVisible = false;
    },

    toRecoveryPage(mode) {
      this.recoveryMode = mode;
      this.isMenuVisible = false;
    },

    closeRecoveryOverlay() {
      this.recoveryMode = RECOVERY_MODE_NONE;
    },

    quickSave() {
      // 快速存档逻辑
      const saveData = {
        chapter: this.chapter,
        currentScene: this.currentScene,
        currentDialogue: this.currentDialogue,
        choicesMade: [...this.choicesMade],
        timestamp: new Date().toISOString()
      };
      // 保存到第一个位置
      let recoveryData = this.recoveryData || [];
      if (recoveryData.length === 0) {
        recoveryData.push(saveData);
      } else {
        recoveryData[0] = saveData;
      }
      this.saveRecoveryDataToStorage(recoveryData);
      prompt.showToast({ message: "快速存档成功" });
      this.closeMenu();
    },

    quickLoad() {
      // 快速读档逻辑
      if (this.recoveryData && this.recoveryData.length > 0) {
        this.loadGameFromState(this.recoveryData[0]);
        prompt.showToast({ message: "快速读档成功" });
      } else {
        prompt.showToast({ message: "没有快速存档" });
      }
      this.closeMenu();
    },

    saveRecoveryData(index) {
      // 普通存档逻辑
      const saveData = {
        chapter: this.chapter,
        currentScene: this.currentScene,
        currentDialogue: this.currentDialogue,
        choicesMade: [...this.choicesMade],
        timestamp: new Date().toISOString()
      };
      
      let recoveryData = this.recoveryData || [];
      if (index === 'new') {
        recoveryData.push(saveData);
      } else {
        recoveryData[index] = saveData;
      }
      
      this.saveRecoveryDataToStorage(recoveryData);
      prompt.showToast({ message: `存档 ${index === 'new' ? recoveryData.length : index + 1} 保存成功` });
      this.closeRecoveryOverlay();
    },

    loadRecoveryData(index) {
      // 读取存档逻辑
      if (this.recoveryData && this.recoveryData[index]) {
        this.loadGameFromState(this.recoveryData[index]);
        prompt.showToast({ message: `读取存档 ${index + 1} 成功` });
      } else {
        prompt.showToast({ message: "存档数据无效" });
      }
      this.closeRecoveryOverlay();
    },

    deleteRecoveryData(index) {
      // 删除存档逻辑
      if (this.recoveryData && this.recoveryData[index]) {
        this.recoveryData.splice(index, 1);
        this.saveRecoveryDataToStorage(this.recoveryData);
        prompt.showToast({ message: `存档 ${index + 1} 已删除` });
      }
    },

    saveRecoveryDataToStorage(data) {
      // 保存存档数据到本地存储
      this.recoveryData = data;
      storage.set({
        key: STORAGE_KEYS.RECOVERY_DATA,
        value: JSON.stringify(data),
        success: () => {
          console.log("[Detail] Recovery data saved successfully");
        },
        fail: (d, c) => {
          console.error(`[Detail] Save recovery data failed: ${d}, ${c}`);
        }
      });
    },

    selectChoice(index) {
      // 选择选项的逻辑
      const scene = this.gameData.scenes[this.currentScene];
      if (scene && scene.choices && scene.choices[index]) {
        this.choicesMade.push({
          sceneIndex: this.currentScene,
          choiceIndex: index,
          choiceText: scene.choices[index].text
        });
        
        // 根据选择跳转到相应的场景或对话
        const choice = scene.choices[index];
        if (choice.nextScene !== undefined) {
          this.currentScene = choice.nextScene;
          this.currentDialogue = 0;
          this.loadScene(this.currentScene);
        } else if (choice.nextChapter !== undefined) {
          // 跳转到下一章节
          this.chapter = choice.nextChapter;
          this.currentScene = 0;
          this.currentDialogue = 0;
          this.loadChapterData(this.chapter);
        }
      }
    },

    skipScene() {
      // 跳过当前场景
      this.currentScene++;
      this.currentDialogue = 0;
      if (this.currentScene >= this.gameData.scenes.length) {
        // 如果超出当前章节，尝试加载下一章节
        this.skipCurrentChapter();
      } else {
        this.loadScene(this.currentScene);
      }
      this.closeMenu();
    },

    skipCurrentChapter() {
      // 跳过当前章节
      let nextChapter = this.chapter + 1;
      if (nextChapter >= this.chapterList.length) {
        prompt.showToast({ message: "已经是最后一章了" });
        return;
      }
      
      this.chapter = nextChapter;
      this.currentScene = 0;
      this.currentDialogue = 0;
      this.loadChapterData(this.chapter);
      this.closeMenu();
    },

    goToHomePage() {
      // 返回主页
      router.replace({ uri: '/pages/index' });
    },

    loadGameFromState(stateData) {
        if (!stateData) { console.error("[Detail] loadGameFromState: stateData is null."); return; }
        console.log(`[Detail] LGFS: Loading state from save - Chapter:'${stateData.chapter}', Scene:${stateData.currentScene}, Dialogue:${stateData.currentDialogue}, Choices:${JSON.stringify(stateData.choicesMade)}`);
        this.isDataLoading = true;
        this.clearTypingTimeout();
        this.resetGameState(true);

        this.chapter = stateData.chapter; // string or number
        this.currentScene = stateData.currentScene; // number
        this.currentDialogue = stateData.currentDialogue; // number
        this.choicesMade = stateData.choicesMade ? [...stateData.choicesMade] : [];
        this.fullDialogueLog = [];

        console.log(`[Detail] LGFS: State applied to component - this.chapter='${this.chapter}', this.currentScene=${this.currentScene}, this.currentDialogue=${this.currentDialogue}, this.choicesMade=${JSON.stringify(this.choicesMade)}`);
        this.loadChapterData(this.chapter); // 传入章节标识
    },

    openHistoryPage() {
        if (this.isMenuVisible || this.recoveryMode !== RECOVERY_MODE_NONE || this.achievedEnding || this.showChoicesUI || this.isDataLoading) {
            return;
        }
        // 确保传递的 fullDialogueLog 中的每一项都包含 chapterId
        const logWithContext = this.fullDialogueLog.map(logEntry => ({
            ...logEntry,
            chapterId: logEntry.chapterId !== undefined ? logEntry.chapterId : this.chapter
        }));

        console.log(`[Detail] Long press. Opening history. Log length: ${logWithContext.length}. Current chapter context for history: '${this.chapter}'`);
        if(logWithContext.length === 0) {
            console.warn("[Detail] fullDialogueLog is empty when trying to open history!");
        }
        router.push({
            uri: 'pages/history',
            params: {
                historyDataParams: {
                    log: logWithContext,
                    chapter: this.chapter,
                }
            }
        });
    }
  }
</script>
