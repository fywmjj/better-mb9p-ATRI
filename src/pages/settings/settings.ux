<template>
  <div class="settings-page-container"> <!-- 新的设置页面根容器 -->
    <!-- 设置界面的背景图，路径也更新了。 -->
    <image class="settings-bg-image" src="/common/images/ev000b.png"></image>
    <!-- 设置界面的文本背景图，也更新了路径。 -->
    <image class="settings-text-bg" src="/common/images/text_bg.png"></image>
    <div class="settings-controls-wrapper">
        <div class="settings-controls">
            <div class="settings-top-buttons">
                <text class="settings-action-text" @click="saveSettingsAndClose()">保存并退出</text>
                <text class="settings-action-text" @click="closeSettingsPage()">直接退出</text>
            </div>
            <div class="setting-item">
                <text class="setting-label">显示速度 ({{ tempSettings.textSpeed }})：</text>
                <!-- 修复：直接将事件的第一个参数（期望是progress值）传递给 updateTempSetting -->
                <slider class="setting-slider" min="20" max="60" step="1" value="{{ tempSettings.textSpeed }}" @change="updateTempSetting('textSpeed', $event.progress)"></slider>
            </div>
            <div class="setting-item">
                <text class="setting-label">文字大小 ({{ tempSettings.textSize }})：</text>
                 <!-- 修复：直接将事件的第一个参数（期望是progress值）传递给 updateTempSetting -->
                 <slider class="setting-slider" min="20" max="32" step="1" value="{{ tempSettings.textSize }}" @change="updateTempSetting('textSize', $event.progress)"></slider>
            </div>
        </div>
        <scroll scroll-y="true" bounces="true" class="settings-preview-scroll">
            <text class="settings-preview-text" style="font-size: {{ tempSettings.textSize }}px;">{{ textPreviewContent }}</text>
        </scroll>
    </div>
  </div>
</template>

<style>
  /* 设置界面样式调整，之前它会跑到右边去，现在应该能正常全屏显示了。这个定位问题可把我折腾坏了，差点以为是Vela的bug呢。😂 */
  .settings-page-container {
    width: 336px;
    height: 480px;
    position: relative;
    background-color: rgba(255, 255, 255, 0.95); /* 继承自原先的overlay样式 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    overflow: hidden;
  }
  .settings-bg-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;}
  .settings-text-bg { position: absolute; bottom: 0; left: 0; width: 100%; height: 165px; }
  /* 修复：移除Vela不支持的box-sizing属性，避免控制台报错。 */
  .settings-controls-wrapper { width: 100%; height: 100%; position: relative; display: flex; flex-direction: column; /* box-sizing: border-box; */ }
  /* 修复：移除Vela不支持的box-sizing属性，避免控制台报错。 */
  .settings-controls { width: 100%; padding: 20px; background-color: rgba(0, 0, 0, 0.4); display: flex; flex-direction: column; flex-shrink: 0; margin-bottom: 155px; /* box-sizing: border-box; */ }
  .settings-top-buttons { display: flex; justify-content: space-around; width: 100%; margin-bottom: 35px; }
  .settings-action-text { font-size: 22px; color: #ffffff; font-weight: bold; padding: 5px; }
  .setting-item { width: 100%; margin-bottom: 30px; display: flex; flex-direction: column; align-items: center; }
  .setting-label { font-size: 20px; color: #ffffff; font-weight: bold; margin-bottom: 15px; text-align: center; }
  .setting-slider { width: 90%; max-width: 250px; }
  .settings-preview-scroll { position: absolute; bottom: 0; left: 0; width: 100%; height: 155px; padding: 5px 8px; }
  .settings-preview-text { color: #ffffff; font-weight: bold; width: 100%; text-align: left; }
</style>

<script>
  import router from "@system.router";
  import storage from '@system.storage';
  import prompt from '@system.prompt';

  const STORAGE_KEYS = { SETTINGS: 'settings' }; // 这个页面只需要用到设置的存储键
  const DEFAULT_SETTINGS = { textSpeed: 40, textSize: 22 };

  export default {
    private: {
      settings: { ...DEFAULT_SETTINGS }, // 存储实际的设置值
      tempSettings: { ...DEFAULT_SETTINGS }, // 用于临时调整的设置值
      textPreviewContent: '',
      textPreviewIndex: 0,
      textPreviewTimerId: null,
      textPreviewText: `Atri -My Dear Moments-\n文字显示样本，用于预览文本速度和大小。\nSample text for previewing speed and size.`,
    },

    onInit() {
      // 页面初始化时，先加载用户之前的设置，然后把临时设置也同步过来。
      // 这样用户进来就能看到自己上次调整过的参数，体验会好很多~ 😋
      console.log("[Settings] onInit: Loading settings.");
      // 修复：直接使用回调函数，避免Promise包装可能带来的兼容性问题。
      storage.get({
        key: STORAGE_KEYS.SETTINGS,
        success: (d) => {
          let s = {};
          if (d) {
            try { s = JSON.parse(d); } catch (e) { console.error("[Settings] Parse settings error:", e); }
          }
          this.settings = { ...DEFAULT_SETTINGS, ...s }; // 与默认设置合并
          console.log("[Settings] Settings loaded:", JSON.stringify(this.settings));
          this.tempSettings = { ...this.settings }; // 应用加载到的设置到临时设置
          this.startTextPreviewAnimation(); // 启动文本预览动画
        },
        fail: (d, c) => {
          console.warn(`[Settings] Load settings fail: ${d}, ${c}`);
          this.settings = { ...DEFAULT_SETTINGS }; // 回退到默认设置
          this.tempSettings = { ...this.settings }; // 应用默认设置到临时设置
          this.startTextPreviewAnimation(); // 启动文本预览动画
        },
        complete: () => {
          // complete 回调通常用于清理或最终状态更新，这里可以留空或添加日志
          console.log("[Settings] storage.get complete.");
        }
      });
    },
    onHide() {
      // 页面隐藏时，停止文本预览动画，节省资源。
      this.stopTextPreviewAnimation();
    },
    onDestroy() {
      // 页面销毁时，确保定时器彻底清除，避免内存泄漏。
      this.stopTextPreviewAnimation();
    },

    // --- 数据加载器 (已整合到onInit中，此函数不再需要) ---
    // loadSettings() { ... }

    // --- 设置逻辑 ---
    // 修复：修改函数签名，直接接收 newValue 作为参数。
    updateTempSetting(key, newValue) {
      // 在模板中我们已经尝试传递 $event.progress。
      // 如果 Vela 运行时直接传递了 progress 值，那么 newValue 就是这个值。
      // 如果 Vela 运行时传递的是一个包含 progress 的对象（如文档所述），那么模板中的 $event.progress 会生效。
      // 如果 Vela 运行时什么都没传或者传了 undefined，那么下面的检查会处理。

      console.log(`[Settings] updateTempSetting called with key: ${key}, received newValue:`, newValue);

      // 再次确认newValue是否为数字，因为模板中传递的 $event.progress 可能在某些情况下仍为 undefined
      if (typeof newValue !== 'number') {
        console.warn(`[Settings] updateTempSetting: newValue is not a number or is undefined. Received:`, newValue);
        // 尝试从 $event (如果它被错误地作为 newValue 传递) 中获取 progress
        // 这一步是为了应对Vela可能存在的更深层次的事件参数传递不一致问题
        if (newValue && typeof newValue.progress === 'number') {
            console.log("[Settings] Fallback: trying to get progress from newValue object itself.");
            newValue = newValue.progress;
        } else {
            console.error("[Settings] updateTempSetting: Cannot determine a valid numeric value for slider change.");
            return; // 无法获取有效值时直接返回
        }
      }

      console.log(`[Settings] updateTempSetting: key=${key}, processed newValue=${newValue}`);

      if (typeof newValue === 'number' && (key === 'textSpeed' || key === 'textSize')) {
          // 确保数值在合理范围内，并取整
          if (key === 'textSpeed') newValue = Math.max(20, Math.min(60, Math.round(newValue)));
          if (key === 'textSize') newValue = Math.max(20, Math.min(32, Math.round(newValue)));
          this.tempSettings[key] = newValue;
          // 速度改变时，重新启动动画，让用户立即看到效果。文字大小改变则直接反映在样式上。
          if (key === 'textSpeed') { this.startTextPreviewAnimation(); }
      } else {
          console.warn(`[Settings] Invalid slider value/key after processing.`);
      }
    },

    saveSettingsAndClose() {
        // 用户点击保存并退出，把临时设置持久化到存储里。
        // 这次我检查了三遍，应该不会再有保存失败的问题了... 🤞
        this.settings = { ...this.tempSettings }; // 将临时设置应用到实际设置
        try {
            const s = JSON.stringify(this.settings);
            storage.set({ key: STORAGE_KEYS.SETTINGS, value: s,
                success: () => {
                    prompt.showToast({ message: '设置已保存' });
                    router.back(); // 返回上一个页面
                },
                fail: (d, c) => {
                    prompt.showToast({ message: `保存失败` });
                    console.error(`[Settings] Save setting fail: ${d}, ${c}`);
                },
                complete: () => {}
            });
        } catch (e) {
            prompt.showToast({ message: '设置数据异常' });
            console.error("[Settings] Stringify settings fail:", e);
        }
    },

    closeSettingsPage() {
      // 用户选择直接退出，不保存任何修改。直接返回上一个页面。
      console.log("[Settings] Closing settings page without saving.");
      router.back();
    },

    // --- 文本预览动画 ---
    startTextPreviewAnimation() {
      // 启动文本预览动画，清空现有内容，从头开始打字效果。
      // 之前这里有点小bug，导致动画不流畅，现在应该丝滑了~ ✨
      this.stopTextPreviewAnimation(); // 停止任何现有动画
      this.textPreviewContent = '';
      this.textPreviewIndex = 0;
      this.animateTextPreview();
    },
    stopTextPreviewAnimation() {
      // 停止文本预览动画的定时器。
      if (this.textPreviewTimerId) {
        clearTimeout(this.textPreviewTimerId);
        this.textPreviewTimerId = null;
      }
    },
    animateTextPreview() {
      // 逐字显示文本的动画逻辑。
      // 修复：使用箭头函数确保 `this` 上下文正确。
      if (this.textPreviewTimerId === null) { return; } // 动画已从外部停止

      if (this.textPreviewIndex < this.textPreviewText.length) {
        this.textPreviewContent += this.textPreviewText.charAt(this.textPreviewIndex);
        this.textPreviewIndex++;
        // 使用箭头函数，更符合现代JS写法，且在某些环境下对this的绑定更稳定
        this.textPreviewTimerId = setTimeout(() => this.animateTextPreview(), this.tempSettings.textSpeed);
      } else {
        // 所有文本显示完毕后，等待一段时间，然后重新开始动画。
        // 等待时间设为2秒，给用户足够时间阅读。
        // 使用箭头函数，更符合现代JS写法，且在某些环境下对this的绑定更稳定
        this.textPreviewTimerId = setTimeout(() => this.startTextPreviewAnimation(), 2000);
      }
    },
  }
</script>
